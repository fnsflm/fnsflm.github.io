{"meta":{"title":"nanodesu~","subtitle":"","description":"","author":"FNSFLM","url":"https://fnsflm.xyz","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"01-28","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"09-29","excerpt":""},{"title":"留言板","text":"","path":"messages/index.html","date":"02-28","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-24","excerpt":""},{"title":"标签","text":"标签合集","path":"tags/index.html","date":"09-29","excerpt":""},{"title":"常用链接","text":"文档pyecharts中文文档 apilolicon-setu","path":"urls/index.html","date":"03-02","excerpt":""}],"posts":[{"title":"git_clone加速方法整理","text":"git_clone加速方法整理之前有兄弟反应git clone时卡在一个地方卡着, 其实这种状况并不稀奇, 网上有许多git clone加速的办法, 整理一下: 使用github的镜像站: 使用方法也很简单, 直接将github.com替换掉即可: 教程, 注: 这种方法只能用于https协议, 不能用git协议, https克隆后怎样修改才能面密登录? 参考: Git之SSH与HTTPS免密码配置 ,或者直接将.git/config中url改成git协议 使用代理, 参考一招 git clone 加速 可能服务器上可能不会装代理, 拷到本地再复制到服务器上也快不少(服务器不会限制上行速度) 对于github这种被”矮墙”的, 更改hosts是常见手段, hosts加上这里的内容 怎么修改hosts? 不同系统文件位置不同, 具体请百度 使用gitee从github导入后再clone gitee, 如果不需要远程提交到github是没问题的, 但如果要PR, 没试过是否可行 nginx反向代理: 教程","path":"2021/03/17/2021-03-17/git_clone加速方法整理/","date":"03-17","excerpt":"","tags":[]},{"title":"办理visa卡经历","text":"办理visa卡经历本人大三学生党一枚, 偶尔有购买国外服务/产品的需求, 比如pixiv/fanbox, apple 美区, goole play, 又或者是saucenao, 买国外电子书, vps之类的. 然后, 我对额度并不在意, 我花呗每个月的3000的额度用不完. pixiv高级会员和fanbox都能使用paypal(国区)消费, 而且普通的单币借记卡也行(甚至支付宝也可以? 我买过一次, 然后就没了) apple美区, google play都可以在淘宝购买礼品卡(国区paypal不行的), 但想着我要是自己能办张visa卡, 干嘛多花冤枉钱 apple美区不能直接绑中国的visa卡, 但可以去美区官网购买礼品卡 成功经历工商银行, 第一次没看清楚, 申请了非校园版的星座卡, 然后第二天申请了校园版星座卡和小黄人, 详细介绍: 星座卡介绍, 小黄人信用卡介绍. 这两张都是免年费, 免外汇兑换手续费. 校园星座卡第一个审批成功, 然后是小黄人, 最后才是非校园版星座卡的拒绝, 一周后(3.12)拿到卡, 然后打电话注销了校园版的星座卡, 因为外观上更喜欢小黄人卡(星座卡其实有更多优惠, 有需要还是选择星座卡, 虽然我不怎么用得上). 我在工行并没有任何储蓄卡, 虽然额度为0 ,居然能给过了, 不愧是中国最大银行, 气度都不一样. 目前因为疫情, 暂时不能出校, 还没激活, 等开始使用后还会继续分享使用情况 失败经历先说说自认为申请可能性比较大的两家银行: 招商银行我在招商银行有一张储蓄卡, 是十几年前我妈给我办的, 我上大学之前,基本上每个月都有几千的进出, 即便现在不怎么用了, 也起码有个大几千的定期在那儿放着. 招商银行有为学生开放的通道, 但没有双币卡或者visa/万事达. 也有说法先要去申请信用卡, 再才能去申请外币信用卡的说法, 听说YOUNG卡很好办 所以我申请了visa全币种卡, 免年费, 免货币兑换手续费. 审批被拒 浦发银行网上都说浦发银行和支付宝有合作, 申请信用卡也看芝麻信用/余额宝, 我芝麻信用720, 余额宝也存有上万元, 平常用支付宝也很频繁. 而且也时不时能看到浦发银行打广告: 你资质良好, 获得最高10万元高额度白金卡申请资格云云 也查过有张浦发银行青春双币卡很好办, 但现在已经没了 信心满满的点了进去, 填了申请(免年费, 免货币兑换手续费(好像是限时)): 结果…第二天就给拒了 中国银行听说中行是仅次工行好申请的, 然而我没能申请成功 网上很多都推荐奥运的锦鲤卡, 可惜现在已经没了 所以我申请了北京冬奥白金信用卡 和卓隽留学信用卡 审批被拒 建设银行和交通银行也都看了下, 并没有找到满意的, 免年费且免外币兑换手续费的, 有的是每年消费多少多少笔就免年费的那种, 本来现在银行卡用的也不多, 一搞忘三五百就没了,所以还是算了. 最后说一下不是说我失败了就代表这个银行难办卡, 毕竟我是学生没收入, 或者有的卡本身就很难办, 还可能有其它各种因素. 但是不得不吹一下工行, 如果大学生办信用卡拿我肯定首先推荐.","path":"2021/03/12/2021-03-12/办理visa卡经历/","date":"03-12","excerpt":"","tags":[]},{"title":"pdftk工具","text":"pdftk工具 PDFtk is a simple tool for doing everyday things with PDF documents. It comes in three flavors: PDFtk Free, PDFtk Pro, and our original command-line tool PDFtk Server. 安装ubuntu apt安装123sudo add-apt-repository ppa:malteworld/ppasudo apt updatesudo apt install pdftk 这种方式我失败了, 应该是被废弃了 snap安装1sudo snap install pdftk 编译安装不建议编译安装, 不如去找找有没有其它工具 12345678sudo apt install default-jre-headless libcommons-lang3-java libbcprov-javasudo apt install git default-jdk-headless ant libcommons-lang3-java libbcprov-javagit clone https://gitlab.com/pdftk-java/pdftk.gitcd pdftkmkdir libsln -st libs /usr/share/java/{commons-lang3,bcprov}.jarant jarjava -jar build/jar/pdftk.jar --help 安装完成: 使用取出(分割)1pdftk &lt;原pdf路径&gt; cat &lt;页码&gt; output &lt;取出文档路径(名字)&gt; 示例: 1pdftk original.pdf cat 1-96 98-end output part1.pdf 分割则多取出几次即可, 如果觉得这样一个个取很费劲, 可以借助bash脚本 123456789101112131415161718192021222324#!/bin/bashf=$1dir=${f%????}name=${dir##*/}mkdir \"$dir\"pre=1t=0for i in \"$@\"do if [ $t -eq 0 ] then let t=$t+1 continue fi pdftk \"$f\" cat \"$pre-$i\" output \"$dir/$name.part$t.pdf\" echo \"finish $pre-$i\" let pre=$i+1 let t=$t+1donepdftk \"$f\" cat \"$pre-end\" output \"$dir/$name.part$t.pdf\"echo \"done\" 使用: 12./pdfsplit.sh &lt;pdf路径&gt; num1[ num2[ num3...]]]# num为页码号 合并1pdftk &lt;pdf路径&gt;[ pdf路径...] cat output &lt;合成pdf路径(名字)&gt; 举例: 1pdftk file1.pdf file2.pdf cat output new.pdf","path":"2021/03/05/2021-03-05/pdftk工具/","date":"03-05","excerpt":"","tags":[]},{"title":"hexo博客压缩css、js等文件","text":"hexo博客压缩css、js等文件 参考: https://www.voidking.com/dev-hexo-gulp/ https://qiita.com/SwuBHj8aKGqBKHet/items/bc206375942c0f6a93fe 安装gulp123456sudo npm install --global gulp-cli# 博客目录下npm install gulp --savenpm install gulp-htmlclean gulp-htmlmin gulp-clean-css gulp-uglify gulp-imagemin --savenpm install gulp-babel babel-preset-env babel-preset-mobx --savenpm install -D @babel/core @babel/preset-react @babel/preset-env --save 配置 gulpfile.jshexo根目录下创建gulpfile.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778let gulp = require('gulp')let cleanCSS = require('gulp-clean-css')let htmlmin = require('gulp-htmlmin')let htmlclean = require('gulp-htmlclean')let babel = require('gulp-babel') /* 转换为es2015 */let uglify = require('gulp-uglify')let imagemin = require('gulp-imagemin')// 设置根目录const root = './public'// 匹配模式， **/*代表匹配所有目录下的所有文件const pattern = '**/*'// 压缩htmlgulp.task('minify-html', function() { return gulp // 匹配所有 .html结尾的文件 .src(`${root}/${pattern}.html`) .pipe(htmlclean()) .pipe( htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true }) ) .pipe(gulp.dest('./public'))})// 压缩cssgulp.task('minify-css', function() { return gulp // 匹配所有 .css结尾的文件 .src(`${root}/${pattern}.css`) .pipe( cleanCSS({ compatibility: 'ie8' }) ) .pipe(gulp.dest('./public'))})// 压缩jsgulp.task('minify-js', function() { return gulp // 匹配所有 .js结尾的文件 .src(`${root}/${pattern}.js`) .pipe( babel({ presets: ['@babel/preset-env'] }) ) .pipe(uglify()) .pipe(gulp.dest('./public'))})// 压缩图片gulp.task('minify-images', function() { return gulp // 匹配public/images目录下的所有文件 .src(`${root}/images/${pattern}`) .pipe( imagemin( [ imagemin.gifsicle({ optimizationLevel: 3 }), imagemin.jpegtran({ progressive: true }), imagemin.optipng({ optimizationLevel: 7 }), imagemin.svgo() ], { verbose: true } ) ) .pipe(gulp.dest('./public/images'))})gulp.task('default', gulp.series('minify-html', 'minify-css', 'minify-js')) 执行gulp命令即可执行压缩 比如我的public文件夹从25M压缩到了13M 将命令设置到package.json中 123\"scripts\": { \"build\": \"hexo clean &amp;&amp; hexo generate &amp;&amp; gulp\", } 然后执行 12npm run buildhexo server # 或者 hexo deploy","path":"2021/02/28/2021-02-28/hexo博客压缩css、js等文件/","date":"02-28","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"https://fnsflm.xyz/tags/css/"},{"name":"hexo","slug":"hexo","permalink":"https://fnsflm.xyz/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://fnsflm.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"js","slug":"js","permalink":"https://fnsflm.xyz/tags/js/"},{"name":"html","slug":"html","permalink":"https://fnsflm.xyz/tags/html/"},{"name":"gulp","slug":"gulp","permalink":"https://fnsflm.xyz/tags/gulp/"}]},{"title":"推荐一个追番(补番)的方法","text":"推荐一个追番(补番)的方法注: 如果你有爬梯困难, 很遗憾, 可以不用看这篇文章了 下载telegram下载地址: https://telegram.org/ 扩展阅读 https://zhuanlan.zhihu.com/p/64595764?utm_source=wechat_session 全平台支持下载, 支持web端. (说起来你可能不信, linux用户的我可能专门为了QQ要打开虚拟机) 而且代码开源, 比某企鹅还担心隐私泄露要强几百倍. tg上开放bot接口, 有着大量丰富的bot 没有限制GHS 各种各样丰富的资源 设置代理一般打开梯子, 能科学上网就不用额外配置 假如你想只tg爬梯而其它应用只访问国内网, 或者哪里出问题了, 使用系统代理就是连不上, 可以手动配置 (电脑端): 找到梯子客户端(N2Ray/Clash/SSR)的socks端口: 很多都是默认的1080端口, 可修改 tg: 左上角三个横 –&gt; Settings –&gt; Advanced –&gt; Connection type –&gt; Use custom proxy 追番我所知道的两个动漫订阅频道(channel): https://t.me/AnimeNep https://t.me/Anime_DD 基本上是实时更新的, 比如下图的史莱姆30集, b站是23.30更新, 这个是23.42更新 可以下载, 也能在线观看, 也不会有和谐, 并且免费. 订阅了哪些番, 也可以从频道公告中查到: https://t.me/roocc/133 https://t.me/Anime_DD/3 个人定阅AnimeNep频道的机器人https://t.me/Animenep_helper_bot ,可以订阅到自己想要的番 补番(一口气看完)私聊机器人, 直接输入番名即可(繁体) 吐槽两句因为要爬梯, 还是有一点门槛的, 如果觉着翻墙有点麻烦, 还不如取花点钱去b站或者忍受广告去樱花动漫. 完全能够理解. 有的人喜欢b站弹幕的氛围, 有的人觉得无所谓甚至反感, 都很正常. 而对于我来说, 为了点弹幕去充b站大会员看番那是不可能的, 打死都不可能. (白嫖万岁!)","path":"2021/02/16/2021-02-16/推荐一个追番(补番)的方法/","date":"02-16","excerpt":"","tags":[{"name":"telegram","slug":"telegram","permalink":"https://fnsflm.xyz/tags/telegram/"},{"name":"ACGN","slug":"ACGN","permalink":"https://fnsflm.xyz/tags/ACGN/"}]},{"title":"安装obs-studio报错","text":"安装obs-studio报错 声明: 我只是写出我安装时遇到的问题, 如果读者碰到了一样的错误, 可以参考我解决的方法, 如果能帮上忙最好不过了 ,如果解决过程中和我的有出入, 恕我无能为力,谷歌上多搜搜吧. 系统环境 windows 7 32位 obs studio 26.1.1 缺少directx组件 [solved] 报错: Your System is missing DirectX compoments … 报错点击确认后会自动弹出微软的下载, 但发现已经不提供下载 We’re sorry, this download is no longer available. 在微软How to install the latest version of DirectX 里提供了directx检测工具的使用方法, 有修复directx的功能 然而诊断结果并没有问题. 最后解决办法 下载obs提供的修复工具dxfix, 点击Go to download下载 注意有如下警示: WARNING: Make sure you’ve at least tried to install DirectX using the DirectX Installer first. DXFix is intended as a last resort if all other solutions have failed. Works on both 32 bit and 64 bit Windows. As this program modifies system files, be sure to disable anti-virus or other firewall / security software before downloading or running it. 成功解决该报错! 缺少 msvcp140_1.dll [solved] The program can’t start because MSVCP140_1.dll is missing from your computer. Try reinstalling the program to fix this problem 网上查到是msvcp140_1在 visual studio 2015 redistributable 中, 去微软官网下载https://support.microsoft.com/en-us/topic/the-latest-supported-visual-c-downloads-2647da03-1eea-4433-9aff-95f26a218cc0 里边的vc_redist.*.exe似乎要爬梯才能下载 安装过程中又出现的错 (摘选): [09B8:0E64][2021-02-04T00:42:50]i301: Applying execute package: Windows7_MSU_x86, action: Install, path: C:\\ProgramData\\Package Cache\\564F02E6419B9858949B0CD5A65E2C8C0944DD88\\packages\\Patch\\x86\\Windows6.1-KB2999226-x86.msu, arguments: ‘“C:\\Windows\\system32\\wusa.exe” “C:\\ProgramData\\Package Cache\\564F02E6419B9858949B0CD5A65E2C8C0944DD88\\packages\\Patch\\x86\\Windows6.1-KB2999226-x86.msu” /quiet /norestart’ [09B8:0E64][2021-02-04T00:42:52]e000: Error 0xc8000222: Failed to execute MSU package. [08A8:0C24][2021-02-04T00:42:52]e000: Error 0xc8000222: Failed to configure per-machine MSU package. [08A8:0C24][2021-02-04T00:42:52]i319: Applied execute package: Windows7_MSU_x86, result: 0xc8000222, restart: None [08A8:0C24][2021-02-04T00:42:52]e000: Error 0xc8000222: Failed to execute MSU package. 完整报错: vc_redist.x86.exe excute error while installing vc_redist.x64.exe, getting error “Failed to configure per-machine MSU package.” 提供了解决方案, 根据日志, 在路径C:\\ProgramData\\Package Cache\\564F02E6419B9858949B0CD5A65E2C8C0944DD88\\packages\\Patch\\x86\\路径下Windows6.1-KB2999226-x86.msu出了问题 12345cd \"C:\\ProgramData\\Package Cache\\564F02E6419B9858949B0CD5A65E2C8C0944DD88\\packages\\Patch\\x86\\\"mkdir XXXXwusa Windows6.1-KB2999226-x86.msu /extract:XXXXDISM.exe /Online /Add-Package /PackagePath:XXXX\\Windows6.1-KB2999226-x86.msu.cabvc_redist.x64.exe /repair DISM发生报错0x800f081e, 完整日志 2021-02-04 02:49:34, Error DISM DISM Package Manager: PID=3456 The package Package_for_KB2999226 is not applicable to the image. - CPackageManagerCLIHandler::Private_ProcessPackageChange 2021-02-04 02:49:34, Info DISM DISM Package Manager: PID=3456 Initiating Changes on Package with values: 4, 7 - CDISMPackage::Internal_ChangePackageState 2021-02-04 02:49:45, Info DISM DISM Package Manager: PID=3456 Error in operation: the package is not applicable. (CBS HRESULT=0x800f081e) - CCbsConUIHandler::Error2021-02-04 02:49:47, Error DISM DISM Package Manager: PID=3456 Failed while processing command add-package. - CPackageManagerCLIHandler::ExecuteCmdLine(hr:0x800f081e) 重新下一个看看: 谷歌搜索Windows6.1-KB2999226-x86后下载 https://www.microsoft.com/zh-cn/download/details.aspx?id=49077 重复上述步骤仍然报错 最后解决办法 暂时放弃上面的办法, 回过头来看是否能下载到msvcp140_1, 在这里搜索并找合适的版本 我选择了最新版, 下载解压后粘贴到C:\\Windows\\System32 …成功启动 吐槽我好傻…缺msvcp140_1补上就行, 我还绕好大一圈. 本来是家里的旧电脑不太行, 重装下系统, 系统从win10降到了win7, 考虑过装个linux更适合旧电脑, 可 对家里人的门槛高了点, 还是装了win7. 这次装个软件真的超出我想象, 一直以为windows系统都是傻瓜式装软件, 没想到有了折腾linux的感觉 其实本来是想找个录屏软件录录课的…但windows上有的录屏软件居然还有打广告收费什么的,我只是想要一个简单的录屏功能而已. 然后找开源工具找到了obs-studio, 现在想想还真傻啊, 浪费了这么多时间. 要是大家有什么好的录屏软件可以推荐以下!","path":"2021/02/03/2021-02-03/安装obs-studio报错/","date":"02-03","excerpt":"","tags":[{"name":"安装配置","slug":"安装配置","permalink":"https://fnsflm.xyz/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"bug","slug":"bug","permalink":"https://fnsflm.xyz/tags/bug/"},{"name":"win7","slug":"win7","permalink":"https://fnsflm.xyz/tags/win7/"}]},{"title":"hexo博客安装live2d(gal主题)","text":"hexo博客安装live2d(gal主题) 博客组件/工具 hexo github page (&amp;&amp; gitee page) hexo-theme-gal 引用项目https://github.com/stevenjoezhang/live2d-widget https://github.com/fghrsh/live2d_api 添加l2d看板娘 参考教程: https://blog.csdn.net/qq_39610915/article/details/90679768 live2d-widget是对hexo-next主题进行的配置, 但实际上并不死板, 很多博客主题都能用, 这里以hexo-theme-gal主题为例添加l2d. 1. 不做任何自定义调整在头&lt;head&gt;中加入font-awesome, 而gal主题已经引用了该插件, 不需要在进行添加 1&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css\"&gt; 在&lt;head&gt;或者&lt;body&gt;中添加autoload.js 1&lt;script src=\"https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js\"&gt;&lt;/script&gt; 即在gal主题中, 找到gal/layout/layout.ejs, 在&lt;body&gt;下添加上面一行, 或者在gal/_partial/head.ejs下添加 2. 能自定义配置l2d方式在gal/layout/layout.ejs中,&lt;body&gt;标签添加如下一行: 1&lt;script src=\"https://domain.blog.your/live2d/autoload.js\"&gt;&lt;/script&gt; 前面的域名为博客的网址, 如果没有绑定域名, 那么为github用户名.github.io 当然使用cdn加速也是可以的, jsdelivr使用格式: cdn.jsdelivr.net/gh/github用户名/仓库名/autoload.js地址 123cd YOURTHEMEDIR# 项目拷贝到主题的source目录下改名为live2d( 名字随便命名, 和上边的一致)git clone https://github.com/stevenjoezhang/live2d-widget source/live2d 修改live2d/autoload.js 1234const live2d_path = \"/live2d/\";// apiPath: \"https://live2d.fghrsh.net/api/\",cdnPath: \"https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/\" apiPath和cdnPath二选一即可 修改live2d/waifu.css live2d/waifu-tips.json可以一定程度的自定义看板娘 这样就基本完成了, 然后基本的hexo g, hexo d就行了 后续问题点击换装没有反应 引用: https://github.com/stevenjoezhang/live2d-widget/issues/58 可能是jsdelivr对文件大小进行了设置, 可以考虑更换cdnPath或者apiPath, apiPath可以换成 https://api.zsq.im/live2d (速度有点慢) https://live2d.fghrsh.net/api/ (似乎是和https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/ 一样的) 也可以自己搭一个后端api, 参照项目: https://github.com/fghrsh/live2d_api 当然, 如果能找到使用了这个项目的博客, 也可通过抓包白嫖别人的api 成果","path":"2021/01/27/2021-01-27/hexo博客安装live2d(gal主题)/","date":"01-27","excerpt":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://fnsflm.xyz/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://fnsflm.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://fnsflm.xyz/tags/%E5%89%8D%E7%AB%AF/"}],"preview":"https://cdn.jsdelivr.net/gh/fnsflmzqdydk/myPicbed/2021/02/27/photo-e93a43.png"},{"title":"废物利用--旧手机搭建服务器","text":"废物利用–旧手机搭建服务器 设备&amp;环境 前期准备 安装 linux deploy ssh连接(内网) 组网 sunny ngrok frp内网穿透(自备公网IP服务器) tips 设备&amp;环境 Adroid手机: Honor 10 COL-AL10 手机操作系统: Android 8.1.0 &amp; EMUI 8.1.0 电脑操作系统: Ubuntu 18.04LTS (如果刷root需要windows系统) adb-1.0.39 (可选) 服务器系统: ubuntu Bionic 前期准备 root是必不可少的, 华为/荣耀的手机会麻烦写,我是找了淘宝让别人远程帮刷,花了80大洋,心疼 我的荣耀10坏的地方还挺多,wifi数据上网都不彳亍, 买了一根支持pd充电的网线拓展坞. 不仅耳机口坏了而且蓝牙坏了,想做个小米音响都不行. 安装adb(可选) 可以不通过电脑数据线连手机安装linux deploy ubuntu可以用apt安装, 可以参考Ubuntu安装adb 手机设置允许USB调制 辅助工具(可选)scrcpy, 能将手机的屏幕投到电脑屏幕上 1sudo snap install scrcpy 手机端推荐工具: 黑客键盘(可选)、JuiceSSH(可选) 安装 linux deploy下载地址: https://github.com/meefik/linuxdeploy/releases 在下载好的位置安装: 1adb install linuxdeploy-2.6.0-259.apk 打开后软件如图所示: 修改配置(右下角), 名字linux可以在左侧栏的配置文件中修改 发行版, 这里给出的不是版本数字而是代号, 可参考Ubuntu 各版本代号简介, 我选择bionic 允许初始化这里勾选后, 我这里出现了问题, ssh启动失败. 建议不勾选. 允许使用SSH服务器(必须) 只做服务器不建议允许使用图形界面和音频输出 其余配置根据自己情况设置/不用改, 可参考我的配置: 然后返回主界面,右上角三个点, 点击配置. 会提示需要root权限. 然后三个点位置点击安装, 进行漫长的安装,&lt;&lt;&lt; deploy说明安装完成 点击启动,倒数第二行的ssh一定要是done, 否则需要重装 ssh连接(内网)电脑端终端或者手机上JuiceSSH(或者其它终端软件)都能连 (电脑)复制公钥 : 1ssh-copy-id -i ~/.ssh/id_rsa.pub 用户名@IP地址 ssh连接,免密登录: 1ssh 用户名@IP地址 命令su可以切换到root 连接成功! 组网大概查了一下, 想让外网访问内部局域网, 有内网穿透和搭建vpn两种方法(openvpn), 这里我使用的内网穿透的方法. 这两种方法都是需要已知公网的服务器的, 或者有的平台会做内网穿透的服务. 花生壳一步一收费,成本高于买服务器自己组. sunny ngrok有免费的内网穿透服务, 但试了一下ssh连时有时输个命令都会卡, 虽然付费的也不贵. 也可以考虑买便宜的服务器. sunny ngrok网址: http://www.ngrok.cc 注册之类的就不说了, 点隧道管理–&gt;开通隧道,最后一个是免费的 点击立即购买,配置如下: ssh使用tcp+22端口, 不建议更换, 如果是搭网页的话使用http+80端口, 隧道名称随便输 ps. 因为免费的只能申请一个, 这里这是演示截图, 和后面的端口号不一样 安装客户端: http://www.ngrok.cc/download.html 这里选择linux arm版 1234567891011# 复制压缩包到服务器,改成自己的用户名/服务器IPscp linux_arm.zip hjy@192.168.5.14:/home/hjy/linux_arm.zip# 连接服务器ssh hjy@192.168.5.14suapt install unzip # 已有unzip或者解包后再传的忽略这步unzip linux_arm.zip # 解压# 启动隧道linux_arm/sunny clientid 隧道ID# 挂起使用setsidsetsid linux_arm/sunny clientid 隧道ID &amp; 隧道ID在隧道管理下: 隧道启动成功界面: (电脑)ssh通过端口转发的域名连接: 1ssh IP地址 -p 端口 端口不能省略,因为是端头转发,不是默认的22了 这样就完成了 frp内网穿透(自备公网IP服务器) 下载: https://github.com/fatedier/frp/releases 一个为客户端, 一个为服务端 配置客户端(手机) 手机cpu的框架是arm, 64位 12345scp frp_0.34.3_linux_arm64.tar.gz 192.168.5.14:/home/hjy/ssh 192.168.5.14tar -xvf frp_0.34.3_linux_arm64.tar.gzcd frp_0.34.3_linux_arm64/rm frps* # 删掉不用的服务端 目录如下: frpc的c指的client客户端, 在这里指的是手机, frps的s指的是server服务端, 这里指具有公网ip的服务器 修改frpc.ini配置文件 123456789[common]server_addr = xxxxserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 启动并挂起: 1./frpc -c frpc.ini &amp; 配置服务端(vps) 123# 关闭防火墙ufw disablesystemctl stop firewalld.service 如果是阿里云配置下面一步: 在控制台云服务器ECS的左侧栏中找到安全组 增添这一行: 配置文件frps.ini可以不做修改 12[common]bind_port = 7000 启动服务端并挂起: 1./frps -c frps.ini 外网ssh连接手机服务器: 1ssh myserver -p 6000 成功! tipstips: frpc.ini中server_addr可以使用自己的域名假如vps出了问题, 可以重新解析域名到新的vps上, 再运行frps(无法和手机在同一网段内) 可以在内网服务器上设置定时任务, 每隔一段时间重新检测连接vps, 防止断连创建cycle_frp.sh, 下边仅供参考, 需要修改路径123456789#!/bin/bashif [ `ps -ef|grep frpc|wc -l` -gt 1 ];then echo [$(date \"+%Y-%m-%d %H:%M:%S\")] frpc正在运行 &gt;&gt; /home/hjy/frp/setupfrp.log;else echo [$(date \"+%Y-%m-%d %H:%M:%S\")] frpc未运行, 重新启动 &gt;&gt; /home/hjy/frp/setupfrp.log; nohup /home/hjy/frp/frp_0.34.3_linux_arm64/frpc -c /home/hjy/frp/frp_0.34.3_linux_arm64/frpc.ini &amp;fi ​ 设置定时任务: 1234chmod +x cycle_frp.sh # 增加权限# cycle_frp.shsudo echo \"0 */1 * * * root bash /home/hjy/frp/cycle_frp.sh\" &gt;&gt;/etc/crontabsudo service cron restart","path":"2021/01/10/2021-1-11/废物利用--旧手机搭建服务器/","date":"01-10","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://fnsflm.xyz/tags/linux/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://fnsflm.xyz/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"服务器","slug":"服务器","permalink":"https://fnsflm.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"网络","slug":"网络","permalink":"https://fnsflm.xyz/tags/%E7%BD%91%E7%BB%9C/"},{"name":"android","slug":"android","permalink":"https://fnsflm.xyz/tags/android/"}]},{"title":"西电软工计组II答案","text":"西电软工计组II答案(2020-2021) 课本:《计算机组成与设计》李伯成 顾新 第六章6.5 6.9 6.10 第七章7.2 7.6 7.7 7.16 7.22 7.23 7.24 7.27 第八章8.3 8.18 8.22 8.27 省略的缺点即是统一编址的优点 8.30 8.31(并没有讲具体的答案) 答案不确定,课本P305 8.33(1) 8.34(2) 第九章9.3 9.8","path":"2021/01/06/2021-1-7/西电软工计组II答案/","date":"01-06","excerpt":"","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://fnsflm.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"关系图graph","text":"使用pyecharts绘制关系图 目的现有数据集email_dev_inside为一个月内某研发人员成员间的邮件往来记录,现要对邮件往来数据进行处理，选择合适的图表，展示公司研发部门的成员组织结构，分别找出每个群体的负责人,并分析研发部门以及每个群体中的主要工作内容 其中,数据的说明如下: 系统环境操作系统: Ubuntu 18.04LTS python: 3.6.9 pyecharts: 1.8.1 IDE: pycharm 步骤 首先对数据进行处理,对from的邮件和to的邮件不重复的标上号(nodedic) 然后是不同主题的处理,使用seaborn对颜色进行分区,不同主题标上不同颜色(colordic) 在将数据整理成graph能接收的形式,绘制图像 利用visualmap增加不同颜色对应的主题(pieces) 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python3import pandas as pdfrom pyecharts.charts import Graphimport pyecharts.options as optsimport seaborn as snsdata = pd.read_excel('data/email_dev_inside.xlsx')colors = sns.color_palette().as_hex()colors.extend(sns.color_palette('Paired').as_hex())colors.extend(sns.hls_palette(8, l=.8, s=.5).as_hex())colors = iter(colors)subjectCount = data['subject'].value_counts()colordic = {i: next(colors) for i in subjectCount.index if subjectCount[i] &gt; 500}colordic['其它'] = next(colors)nodedic = {}links = []linksdic = {i: [] for i in colordic.keys()}j = 0for i in range(len(data)): s = data['from'][i] t = data['to'][i] c = data['subject'][i] if s not in nodedic.keys(): nodedic[s] = j j += 1 if t not in nodedic.keys(): nodedic[t] = j j += 1 if c not in colordic.keys(): c = '其它' links.append( opts.GraphLink(source=nodedic[s], target=nodedic[t], linestyle_opts=opts.LineStyleOpts(color=colordic[c])))pieces = [{'max': int(subjectCount[i]), 'label': i, 'color': colordic[i]} for i in colordic.keys() if i != '其它']pieces.append({'max': 1, 'label': '其它', 'color': colordic['其它']})graph = Graph( init_opts=opts.InitOpts(width=\"1400px\", height=\"800px\")).add(\"邮件往来关系图\", nodes=map( lambda x: {'name': x}, nodedic.values()), links=links, ).set_global_opts( visualmap_opts=opts.VisualMapOpts( is_piecewise=True, pieces=pieces ))graph.render('result/email.html') 效果email.html 结果分析从结果很容易看出,该公司分成了三大部分,分别由248、174、173来负责,由1负责的小部分,概要设计、需求调研等较多,可以初步判定174的部分是软件的开发阶段,设计并开发程序.由29、30的小部分红色的需求较多,可能248负责的是需求分析部分,而最后的173则是测试部分 吐槽pyecharts居然完全不支持对线的分类,通过linestyle可以标上颜色,但无法设置鼠标悬浮时的标签,最后的legend是用visualmap强行加上的,也没有以往的点击后显示/隐藏的效果. 关于线的颜色的设置,我的代码里是拿不同主题的seaborn color palette拼接,因为超过一定数量(好像是9个)就会自动循环(有重复),但效果并不好,我也试过用#FFFFFF平均分成25个颜色但效果也不好.需要数量比较多的区分度高的颜色还是一件听困难的事儿,只能想办法自己判断可能是同一个阶段的标签在合并一起然后去划分 这个关系图只是个半成品,想要完整的搞出来将会很费劲,以后有时间再搞吧","path":"2020/12/17/2020-12-17/关系图graph/","date":"12-17","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://fnsflm.xyz/tags/python/"},{"name":"pyecharts","slug":"pyecharts","permalink":"https://fnsflm.xyz/tags/pyecharts/"},{"name":"绘图","slug":"绘图","permalink":"https://fnsflm.xyz/tags/%E7%BB%98%E5%9B%BE/"},{"name":"数据可视化","slug":"数据可视化","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"关系图","slug":"关系图","permalink":"https://fnsflm.xyz/tags/%E5%85%B3%E7%B3%BB%E5%9B%BE/"}]},{"title":"kafka安装配置","text":"kafka安装配置系统环境 操作系统:Ubuntu 18.04LTS java: 1.8.0_201 生产者:master节点:10.177.82.86 消费者:slave1节点:10.177.82.88 下载kafka官网上下载:http://kafka.apache.org/downloads 没有查到有版本依赖的关系,下载最新版本 使用清华源,速度很快 解压到自定义的位置,我解压到~/software 配置kafka配置环境变量,打开~/.bashrc 12export KAFKA_HOME=/home/hjy/software/kafka_2.13-2.6.0export PATH=$PATH:$KAFKA_HOME/bin source ~/.bashrc更新配置 在其它节点上重复这个操作 将kafka复制到其它节点上 1scp -r ../kafka_2.13-2.6.0 slave1:/home/hjy/software/ 修改配置文件(只给出修改的部分) master节点conf/server.properties 123broker.id=0listeners=PLAINTEXT://master:9092zookeeper.connect=master:2181,slave1:2181 slave1节点conf/server.properties 123broker.id=1listeners=PLAINTEXT://slave1:9092zookeeper.connect=master:2181,slave1:2181 所有节点都需要修改的部分(可以选择修改之后再复制到其它节点上): conf/producer.properties 1bootstrap.servers=master:9092,slave1:9092 conf/consumer.properties 1bootstrap.servers=master:9092,slave1:9092 启动kafka启动zookeeper(所有节点都启动),可以使用已经安装好的zookeeper 1zkServer.sh start 也能使用自带的zookeeper: 1zookeeper-server-start.sh config/zookeeper.properties &amp; 启动kafka(所有节点启动) 1kafka-server-start.sh -daemon config/server.properties 创建topic(master节点) 1kafka-topics.sh --create --zookeeper c0:2181 --replication-factor 1 --partitions 1 --topic test-topic master上创建生产者 1kafka-console-producer.shbroker-list slave1:9092 --topic test-topic slave1上创建消费者 1kafka-console-consumer.sh --bootstrap-server slave1:9092 --topic test-topic master上输入字符串能够同步显示在slave1上,说明kafka搭建成功!","path":"2020/12/15/2020-12-15/kafka安装配置/","date":"12-15","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://fnsflm.xyz/tags/java/"},{"name":"大数据","slug":"大数据","permalink":"https://fnsflm.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"kafka","permalink":"https://fnsflm.xyz/tags/kafka/"}]},{"title":"大数据小项目-新闻爬取与处理","text":"大数据大作业-新闻爬取与处理 前言 问题描述 步骤概述 hadoop环境 系统环境 hadoop单机配置 hbase单机配置 启动 HBase建表 爬取新闻 爬取新闻列表 爬取新闻内容 mapreduce开发 结果 大数据大作业-新闻爬取与处理前言 今日头条拥有海量的新闻，以海量文本数据为主，同时也包括图片、视频、音频、用户信息等其他类型的数据. 在批计算方面，今日头条要频繁地对海量新闻文本进行统计，这里的统计任务为每篇新闻标题的字数、正文的字数与下方评论的字数 在实时计算方面，今日头条需要应对实时的用户点击流，故需要设计流计算引擎 在存储方面，需要对海量的新闻文本数据进行的存储，还要对图片、视频、音频等多媒体数据进行存储。同时，还要存储用户的注册信息等 在消息处理方面，因为整个系统包括多个计算或存储组件，故需要消息中间件承担数据总线的作用 问题描述 将以上四个方面，归纳到统一的一套计算-存储架构中。 分析问题，选取合适的海量数据处理技术，设计总体的存储与计算方案 参照需求，自拟数据的存储结构，设计数据存储方案 步骤概述 爬取今日头条的新闻内容 将爬取的内容存入hbase数据库中 将hbase中的数据作为输入,使用mapreduce对字数进行统计 hadoop环境系统环境 操作系统: Ubuntu 18.04.5 LTS java: 1.8.0_201 hadoop: 3.1.4 hbase: 2.3.3 IDE: IntelliJ IDEA 2019.1 hadoop单机配置core-site.xml 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/home/hjy/software/hadoop-3.1.4/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;!--value&gt;hdfs://master:9000&lt;/value--&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml 12345678910111213141516171819&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/home/hjy/software/hadoop-3.1.4/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/home/hjy/software/hadoop-3.1.4/tmp/dfs/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.http.address&lt;/name&gt; &lt;!--value&gt;master:9870&lt;/value--&gt; &lt;value&gt;localhost:9870&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; workers 1localhost hbase单机配置hbase-site.xml 123456789101112131415161718192021222324&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.tmp.dir&lt;/name&gt; &lt;value&gt;file:/home/hjy/software/hbase-2.3.3/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;!--value&gt;hdfs://master:9000/hbase&lt;/value--&gt; &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;!--value&gt;slave1,slave2,slave3&lt;/value--&gt; &lt;value&gt;localhost&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml: 复制hadoop中的 regionservers 1localhost 启动12start-dfs.shstart-hbase.sh NameNode,DataNode,SecondaryNameNode说明hadoop启动成功 HMaster,HRegionServer说明hbase启动成功 HBase建表进入命令行模式 1hbase shell 创建两张表 12create 'jrtt','content'create 'jrtt_comment','comment' 表jrtt中,id簇有列content用来存放title标题,url链接和内容text 表jrrt_comment中,comment的列有评论内容content和发表评论人的用户名user 爬取新闻爬取新闻列表我使用的是火狐浏览器,页面任意处右击,点击检查元素,点击网络后刷新,点击右侧的xhr,再点击方法让列表按照方法顺序排列,在get方法依次点击寻找 可以看到以/api/pc/feed/开头的存储着新闻相关的信息,而鼠标下拉时刷新,会弹出新的新闻,这种ajax网页一般可以有两种方式,一种是使用ajax接口,另一种是使用selenium模拟浏览器的行为进行刷新,这里不展开了. 这里只爬取最开始的新闻列表,链接为:https://www.toutiao.com/api/pc/feed/?min_behot_time=0&amp;category=news_hot&amp;utm_source=toutiao&amp;widen=1&amp;tadrequire=true&amp;_signature=_02B4Z6wo00d01MO9SVwAAIBALDo1313Nw4TDuE3AAG9C9N8bY9z-NUd3bpGXDsb0OHxMjHVy6J0NFFd8RUDSRVxtH.xcSiFMki7.WyPyW24kzzkl-KMiMJ9QQXhJKSniCOLi0bDBKlm1zJhkb3 在maven项目中引入Gson来解析json 12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; 爬虫代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 解析json获取链接列表// 从json解析出来的url需要跳转,使用了httpclient设置拿取不跳转时的响应头获取链接 private ArrayList&lt;String&gt; getURLList() { ArrayList&lt;String&gt; ls = new ArrayList&lt;&gt;(); String js = loadPage(\"https://www.toutiao.com/api/pc/feed/?min_behot_time=0&amp;category=news_hot&amp;utm_source=toutiao&amp;widen=1&amp;tadrequire=true&amp;_signature=_02B4Z6wo00d01MO9SVwAAIBALDo1313Nw4TDuE3AAG9C9N8bY9z-NUd3bpGXDsb0OHxMjHVy6J0NFFd8RUDSRVxtH.xcSiFMki7.WyPyW24kzzkl-KMiMJ9QQXhJKSniCOLi0bDBKlm1zJhkb3\"); JsonObject jsonObject = (JsonObject) new JsonParser().parse(js); JsonArray jsList = jsonObject.get(\"data\").getAsJsonArray(); for (JsonElement i : jsList) { JsonObject js2 = i.getAsJsonObject(); System.out.println(\"title: \" + js2.get(\"title\").getAsString()); String url = \"https://www.toutiao.com\" + js2.get(\"source_url\").getAsString(); CloseableHttpClient httpClient = HttpClientBuilder.create().build(); HttpGet httpGet = new HttpGet(url); httpGet.setHeader(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\"); httpGet.setHeader(\"Accept-Encoding\", \"gzip, deflate\"); httpGet.setHeader(\"Accept-Language\", \"zh-CN,zh;q=0.9\"); httpGet.setHeader(\"Cache-Control\", \"max-age=0\"); httpGet.setHeader(\"User-Agent\", \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0\"); HttpParams params = new BasicHttpParams(); params.setParameter(\"http.protocol.handle-redirects\", false); httpGet.setParams(params); try{ HttpResponse response = httpClient.execute(httpGet); url = response.getFirstHeader(\"Location\").getValue(); System.out.println(\"url: \" + url); ls.add(url); }catch(Exception e){ e.printStackTrace(); } } return ls; }// 获取给定链接的json字符串private String loadPage(String url) { StringBuilder json = new StringBuilder(); try { URL urlObject = new URL(url); HttpURLConnection uc = (HttpURLConnection) urlObject.openConnection(); uc.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0\"); BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream(), \"GBK\")); String inputLine; while ((inputLine = in.readLine()) != null) { json.append(inputLine); } in.close(); } catch (IOException e) { e.printStackTrace(); } return json.toString(); } 爬取新闻内容直接从链接请求结果只会返回js代码,没有想要的文本内容,查资料发现,需要__ac_signature放入请求cookie中,才能获取想要文本内容.奈何本人一点js的知识也没有,所以改用selenium来模拟浏览器的行为,达到爬取的目的 pom.xml加入依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java --&gt;&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 下载驱动,我使用的是火狐浏览器:https://github.com/mozilla/geckodriver/releases 相关文档也提供了Java API 使用jsoup对html进行解析,加入依赖: 12345&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.12.1&lt;/version&gt;&lt;/dependency&gt; 启动selenium,获取html 123456// 设置驱动System.setProperty(\"webdriver.gecko.driver\", \"src/geckodriver\");WebDriver driver = new FirefoxDriver();driver.manage().window().maximize();driver.get(url);String html = driver.getPageSource(); 获取标题和正文内容代码: 12345678910111213private String getTitle(String html) { Document document = Jsoup.parse(html); return document.head().getElementsByTag(\"title\").text();}private String getContent(String html) { Document document = Jsoup.parse(html); Elements article = document.body().getElementsByTag(\"article\"); StringBuffer content = new StringBuffer(); for (Element e : article.select(\"p\")) { content.append(e.text()); } return content.toString();} 获取评论 123456789101112131415161718192021222324252627// 每个用户的评论存在一个字符串中,然后使用ArrayList存储// 链接中,offset是偏移量,请求从的几个评论之后的评论,count最大值为50,gid是getURLList()的group后面的一串数字,group_id和item_id一样private ArrayList&lt;String&gt; getComments(String gid, String signature) { ArrayList&lt;String&gt; comments = new ArrayList&lt;&gt;(); int i = 0; while (true) { String url = \"https://www.toutiao.com/article/v2/tab_comments/?aid=24&amp;app_name=android&amp;offset=\" + i + \"&amp;count=50&amp;group_id=\" + gid + \"&amp;item_id=\" + gid + \"&amp;_signature=\" + signature; System.out.println(url); String js = loadPage(url); JsonObject jsonObject = (JsonObject) new JsonParser().parse(js); JsonArray jsList = jsonObject.get(\"data\").getAsJsonArray(); if (jsList.size() == 0) break; for (JsonElement jl : jsList) { JsonObject js2 = jl.getAsJsonObject(); JsonObject js3 = js2.get(\"comment\").getAsJsonObject(); comments.add(js3.get(\"text\").getAsString()); i++; } try { Thread.sleep(200); } catch (Exception e) { e.printStackTrace(); } } return comments; } mapreduce开发maven导入以下依赖(或者从已经下好的hadoop中导入jar包) 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;3.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt; &lt;version&gt;3.1.4&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-it&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt;&lt;/dependency&gt; 代码并不长,但我是第一次写,各方面还是花了点时间的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.hjy.jrtt;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.hbase.HBaseConfiguration;import org.apache.hadoop.hbase.TableName;import org.apache.hadoop.hbase.client.*;import org.apache.hadoop.hbase.io.ImmutableBytesWritable;import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;import org.apache.hadoop.hbase.mapreduce.TableMapper;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.log4j.PropertyConfigurator;import java.io.IOException;import java.util.Date;public class Main { public static void main(String[] args) throws Exception { // 加载log4j日志的配置,可以忽略 PropertyConfigurator.configure(\"log4j.properties\"); // 爬取新闻和入库,其实可以和mapreduce的工作分开 ArrayList&lt;News&gt; newsList = (new GetNews()).getNewss(); new putHbase(newsList); Configuration conf = new Configuration(); Job job = Job.getInstance(conf, \"word count\"); job.setJarByClass(Main.class); job.setMapperClass(MyMapper.class); job.setReducerClass(MyReducer.class); // 设置输出的类 job.setOutputKeyClass(Text.class); job.setOutputValueClass(LongWritable.class); // 设置map的入口,参数分别填入:hbase表名,scan,map的class,交给reduce的key,交给reduce的value,job // 其中,如果对表要进行一部分筛选的话,scan可以设置其它参数后再传入 TableMapReduceUtil.initTableMapperJob(\"jrtt_comment\".getBytes(), new Scan(), MyMapper.class, Text.class, IntWritable.class, job); // 输出以文件的形式,要设置一个不存在的文件夹,如果有存在的则会报错,我用日期来命名,防止重复 FileOutputFormat.setOutputPath(job, new Path(\"src/data/output/\" + (new Date()).toString())); if (!job.waitForCompletion(true)) { System.out.println(\"word count failed!\"); } } // 继承的Reducer对应的是以文件作为输出的,如果要输出给hbase则使用TableReducer // 尖括号中的四个类分别是map输出的键和值作为reduce的输入,然后是reduce的输出键和值 public static class MyReducer extends Reducer&lt;Text, IntWritable, Text, LongWritable&gt; { private LongWritable result = new LongWritable(); @Override protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException { int sum = 0; int title = 0; int content = 0; for (IntWritable val : values) { sum += val.get(); } result.set(sum); Configuration conf = HBaseConfiguration.create(); conf.set(\"hbase.zookeeper.quorum\", \"localhost\"); Connection conn = ConnectionFactory.createConnection(conf); Table table = conn.getTable(TableName.valueOf(\"jrtt\")); Scan scan = new Scan(); ResultScanner rs = table.getScanner(scan); Get get = new Get(key.getBytes()); Result res = table.get(get); String titlestr = new String(res.getValue(\"content\".getBytes(), \"title\".getBytes())); title = titlestr.length(); content = new String(res.getValue(\"content\".getBytes(), \"text\".getBytes())).length(); context.write(new Text(titlestr), new LongWritable(Long.parseLong(key.toString()))); context.write(new Text(\"title\"), new LongWritable(title)); context.write(new Text(\"content\"), new LongWritable(content)); context.write(new Text(\"comment\"), result); context.write(new Text(\"all\"), new LongWritable(title + content + sum)); } } // 继承TableMapper是和hbase对接的 // 尖括号中两个类型为map输出的键和值 public static class MyMapper extends TableMapper&lt;Text, IntWritable&gt; { private static IntWritable wordNum = new IntWritable(); private static Text id = new Text(); @Override protected void map(ImmutableBytesWritable key, Result value, Context context) throws IOException, InterruptedException { id.set(value.getValue(\"comment\".getBytes(), \"ttid\".getBytes())); String comment = new String(value.getValue(\"comment\".getBytes(), \"comment\".getBytes())); wordNum.set(comment.length()); // map的输出 context.write(id, wordNum); } }} 结果 完整代码: https://github.com/fnsflmzqdydk/jrtt_mapreduce 本文链接: https://fnsflm.gitee.io/2020/12/12/2020-12-12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E6%96%B0%E9%97%BB%E7%88%AC%E5%8F%96%E4%B8%8E%E5%A4%84%E7%90%86/","path":"2020/12/12/2020-12-12/大数据小项目-新闻爬取与处理/","date":"12-12","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://fnsflm.xyz/tags/java/"},{"name":"hbase","slug":"hbase","permalink":"https://fnsflm.xyz/tags/hbase/"},{"name":"大数据","slug":"大数据","permalink":"https://fnsflm.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hadoop","slug":"hadoop","permalink":"https://fnsflm.xyz/tags/hadoop/"},{"name":"mapreduce","slug":"mapreduce","permalink":"https://fnsflm.xyz/tags/mapreduce/"},{"name":"爬虫","slug":"爬虫","permalink":"https://fnsflm.xyz/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"hbase配置","text":"hbase配置安装环境 Ubuntu 18.04 LTS(主机+3台虚拟机) hadoop-3.1.4 java: openjdk 11.0.9.1 节点: master,slave1,slave2,slave3 下载hbase下载hbase前要注意版本的对应关系在官网有版本对应表 hbase和jdk的对应关系:(亲测openjdk11不能用) hbase和hadoop的对应关系 我这里选择hbase-2.3 安装并配置hbase修改配置文件我安装在~/software目录下 123456tar -xzvf hbase-2.3.3-bin.tar.gzcd hbase-2.3.3/# 修改三个配置文件vim conf/hbase-site.xmlvim conf/regionserversvim conf/hbase-env.sh 参考官网手册 hbase-site.xml: hbase.rootdir的端口和hadoop中core-site.xml里fs.defaultFS的端口一致,有的版本是8020 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://master:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;slave1,slave2,slave3&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; regionsevers: 123slave1slave2slave3 hbase-env.sh: 12export HBASE_MANAGES_ZK=true # 这里采用hbase内置的zookeeperexport JAVA_HOME=/home/hjy/software/java/jdk1.8.0_201 # 自己的jdk路径 复制hadoop配置官网上提供了三中方式,其中最简单的还是第二种, 将hadoop中hdfs-site.xml复制到conf下 1cp ../hadoop-3.1.4/etc/hadoop/hdfs-site.xml conf/ 配置环境变量所有节点都要配置 打开/etc/profile或~/.bashrc,添加: 12export HBASE_HOME=/home/hjy/software/hbase-2.3.3/export PATH=$PATH:$HBASE_HOME/bin source ~/.bashrc 刷新配置 拷贝hbase到其它节点123scp -r ../hbase-2.3.3/ slave1:/home/hjy/software/scp -r ../hbase-2.3.3/ slave2:/home/hjy/software/scp -r ../hbase-2.3.3/ slave3:/home/hjy/software/ 启动hbase12start-dfs.sh # 启动hadoopstart-hbase.sh # 启动hbase 使用jps查看是否启动成功,master节点会有HMaster,其它节点(在regionsevers中的)会有HRegionServer 最后,浏览器上打开http://master:16010/master-status查看节点状态 配置成功! 配置过程中的错误在启动hadoop的时候打开master:9870,livenodes显示3个,点进去只看到一个三个虚拟机复制镜像后,没有改主机名,所以只识别出了一个 在/etc/hostname下,分别改为slave1,slave2,slave3 /usr/local/hadoop/libexec/hadoop-functions.sh: 行 2360: HADOOP_ORG.APACHE.HADOOP.HBASE.UTIL.GETJAVAPROPERTY_USER：无效的变量名在hbase-env.sh中添加一行 1export HBASE_DISABLE_HADOOP_CLASSPATH_LOOKUP=\"true\" 参考这篇博客 Hbase region in transition且region severs一个也没有网上查了一下,很多原因导致这个错误,我最后是通过查日志解决的,master的日志没出现问题,在slave的日志中查到: 12345672020-11-24 19:52:59,806 WARN [regionserver/slave1:16020] regionserver.HRegionServer: Unable to connect to master. Retrying. Error was:java.net.UnknownHostException: can not resolve hjy-thinkpad-t470p,16000,1606218112070 at org.apache.hadoop.hbase.ipc.AbstractRpcClient.createAddr(AbstractRpcClient.java:430) at org.apache.hadoop.hbase.ipc.AbstractRpcClient.createBlockingRpcChannel(AbstractRpcClient.java:508) at org.apache.hadoop.hbase.regionserver.HRegionServer.createRegionServerStatusStub(HRegionServer.java:2689) at org.apache.hadoop.hbase.regionserver.HRegionServer.reportForDuty(HRegionServer.java:2737) at org.apache.hadoop.hbase.regionserver.HRegionServer.run(HRegionServer.java:987) 由于slave虚拟机无法解析master的hostname,所以无法链接master所产生的问题 我的主机master的hostname(hjy-ThinkPad-T470p)和hosts中设置的域名(master)并不相同,而三个slave的hostname和域名都叫slave 下面是我的hosts文件 12345678127.0.0.1 localhost# 127.0.1.1 hjy-ThinkPad-T470p # hostname # hadoop10.177.82.86 master hjy-ThinkPad-T470p10.177.82.88 slave110.177.82.89 slave210.177.82.90 slave3","path":"2020/11/24/2020-11-24/hbase配置/","date":"11-24","excerpt":"","tags":[{"name":"安装配置","slug":"安装配置","permalink":"https://fnsflm.xyz/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"java","slug":"java","permalink":"https://fnsflm.xyz/tags/java/"},{"name":"hbase","slug":"hbase","permalink":"https://fnsflm.xyz/tags/hbase/"},{"name":"大数据","slug":"大数据","permalink":"https://fnsflm.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"javafx设置背景图片","text":"javafx设置背景图片使用css setstyle方式但使用IntelliJ IDEA时,在写路径时会提示错误,但实际上是可以不管的路径写项目的工作目录的相对路径即可 项目的路径如下: 1234567891011121314151617181920212223242526├── pom.xml├── src│ ├── data│ │ ├── Book_opened.png│ │ ├── Book_opened.svg│ │ └── illust_75942276_20200606_004558.jpg│ ├── main│ │ └── java│ │ └── com│ │ └── hjy│ │ └── library│ │ ├── App.java│ │ ├── LoginStage.java│ │ ├── ManagerStage.java│ │ └── SQLPlugin.java│ ├── style│ │ ├── background.css│ │ ├── background_test.css│ │ └── test_css.html│ └── test│ └── java│ └── com│ └── hjy│ └── library│ └── AppTest.java setsyle方式:12345BorderPane backpane = new BorderPane();backpane.setStyle(\"-fx-background-image: url(\" + \"file:src/data/illust_75942276_20200606_004558.jpg\" + \"); \" + \"-fx-background-position: center center; \" + \"-fx-background-repeat: stretch;\" + \"-fx-background-color: transparent;\"); 错误的提示不用管 css文件方式[报错]:这是在JavaFX How to set scene background image上抄的方法,但奈何无论怎么改图片的位置,改图片的相对/绝对路径,或者改成链接,都不管用 1234567#pane{ -fx-background-image: url(file:src/data/illust_75942276_20200606_004558.jpg); -fx-background-repeat: stretch; /*-fx-background-size: 900 506;*/ -fx-background-position: center center; /*-fx-effect: dropshadow(three-pass-box, black, 30, 0.5, 0, 0);*/} 1234StackPane stackPane = new StackPane();stackPane.setId(\"pane\");Scene scene = new Scene(stackPane,600,400);scene.getStylesheets().add(getClass().getResource(\"file:src/style/background.css\").toExternalForm()); 报错: 123456789101112131415161718192021222324252627282930Exception in Application start methodjava.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.sun.javafx.application.LauncherImpl.launchApplicationWithArgs(LauncherImpl.java:389) at com.sun.javafx.application.LauncherImpl.launchApplication(LauncherImpl.java:328) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at sun.launcher.LauncherHelper$FXHelper.main(LauncherHelper.java:767)Caused by: java.lang.RuntimeException: Exception in Application start method at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:917) at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$412(LauncherImpl.java:182) at java.lang.Thread.run(Thread.java:748)Caused by: java.lang.NullPointerException at com.hjy.library.LoginStage.&lt;init&gt;(LoginStage.java:54) at com.hjy.library.App.start(App.java:17) at com.sun.javafx.application.LauncherImpl.lambda$launchApplication1$419(LauncherImpl.java:863) at com.sun.javafx.application.PlatformImpl.lambda$runAndWait$399(PlatformImpl.java:326) at com.sun.javafx.application.PlatformImpl.lambda$null$397(PlatformImpl.java:295) at java.security.AccessController.doPrivileged(Native Method) at com.sun.javafx.application.PlatformImpl.lambda$runLater$398(PlatformImpl.java:294) at com.sun.glass.ui.InvokeLaterDispatcher$Future.run(InvokeLaterDispatcher.java:95) at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method) at com.sun.glass.ui.gtk.GtkApplication.lambda$null$203(GtkApplication.java:139) ... 1 moreException running application com.hjy.library.App","path":"2020/11/22/2020-11-22/javafx设置背景图片/","date":"11-22","excerpt":"","tags":[{"name":"javafx","slug":"javafx","permalink":"https://fnsflm.xyz/tags/javafx/"},{"name":"java","slug":"java","permalink":"https://fnsflm.xyz/tags/java/"},{"name":"css","slug":"css","permalink":"https://fnsflm.xyz/tags/css/"}]},{"title":"sql创建函数过程中的报错","text":"sql创建函数过程中的报错 操作系统：Linux Ubuntu 18.04 LTS mysql: 8.0.23 1. 需要修改语句结束符号：DELIMITER最开始sql代码： 123456CREATE DEFINER=`root`@`%` FUNCTION adddeposit()RETURNS INTEGERBEGIN INSERT INTO ACCOUNT016 VALUES ('A-100lsaj','Pownal',777);RETURN 0;END; 报错： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘END’ at line 1 在函数结束前用DELIMITER //将默认的\";\"改为\"//\" 12345678DELIMITER //CREATE DEFINER=`root`@`%` FUNCTION adddeposit()RETURNS INTEGERBEGIN INSERT INTO ACCOUNT016 VALUES ('A-100lsaj','Pownal',777);RETURN 0;END;// 2. DETERMINISTIC, NO SQL 和 READS SQL DATA问题报错： ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you might want to use the less safe log_bin_trust_function_creators variable) 参考Mysql在导入时遇到DETERMINISTIC, NO SQL 和 READS SQL DATA问题得以解决 mysql下执行 1set global log_bin_trust_function_creators=TRUE 然后在配置文件my.cnf最后追加一行，防止以后还需要修改 1su -c \"echo log-bin-trust-function-creators=1 &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf\" root ps：配置文件的位置需要自己去找，还有一个看上去似的目录/etc/mysql/conf.d/mysql.cnf，看上去也像是配置文件但却是不对的，要加到[mysqld]后，否则数据库无法打开 3. definer报错报错： The user specified as a definer (‘root’@’%’) does not exist 将%改为localhost或者远程登录的ip地址，如果仍然有错，那说明权限出了问题，要给对应用户正确的host权限 12345678DELIMITER //CREATE DEFINER=`root`@`localhost` FUNCTION adddeposit()RETURNS INTEGERBEGIN INSERT INTO ACCOUNT016 VALUES ('A-100lsaj','Pownal',777);RETURN 0;END;//","path":"2020/11/17/2020-11-17/sql创建函数过程中的报错/","date":"11-17","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"https://fnsflm.xyz/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://fnsflm.xyz/tags/sql/"}]},{"title":"fcitx重启后快捷键失效","text":"fcitx重启后快捷键失效一般是直接在fcitx-configtool中去修改快捷键，但我这里出现了重启失效的情况首先找到fcitx的配置文件我的是在~/.config/fcitx/config根据文件中的注释修改快捷键后，可以尝试重启，如果重启后生效那么解决了该问题如果还不行，可以尝试将配置文件设为只读的 1chmod 400 ~/.config/fcitx/config 因为我在开机后使用stat查看该配置文件修改时间，是在开机后就修改了","path":"2020/10/28/2020-10-28/fcitx重启后快捷键失效/","date":"10-28","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://fnsflm.xyz/tags/linux/"},{"name":"fcitx","slug":"fcitx","permalink":"https://fnsflm.xyz/tags/fcitx/"}]},{"title":"kdenlive无法导出多层视频","text":"kdenlive无法导出多层视频想在视频里加个字幕，然后导出只有字幕和背景音乐，没有视频 我的解决办法：不是双击点开项目或者在启动栏点图标点开，而是在终端里直接输入kdenlive直接打开我也不知道为什么这样就可行了，欢迎大家在评论区讨论ps：终端去打开能看到警告或者一些报错，这也有利于其它问题的解决","path":"2020/10/18/2020-10-17/kdenlive无法导出多层视频/","date":"10-18","excerpt":"","tags":[{"name":"kdenlive","slug":"kdenlive","permalink":"https://fnsflm.xyz/tags/kdenlive/"}]},{"title":"ubuntu上安装pixiv-nginx","text":"ubuntu上安装pixiv-nginx 原文：https://2heng.xin/2017/09/19/pixiv/ 安装nginx1sudo apt install nginx 安装后文件在/etc/nginx下 nginx -v查看是否下载成功 导入证书证书在这儿，下载后导入浏览器，这里以火狐浏览器为例，其它浏览器百度可以搜到 首选项里搜索证书 点击查看证书，并导入 配置nginx下载https://github.com/mashirozx/Pixiv-Nginx/tree/master/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E9%9D%9EWindows%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%EF%BC%89的内容，复制`ca`，`nginx.conf`到`/etc/nginx` 123sudo mv /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backsudo cp -r 配置文件（非Windows用户使用）/nginx.conf /etc/nginx/nginx.confsudo cp -r 配置文件（非Windows用户使用）/ca/ /etc/nginx/ca/ 配置host将这里的内容复制到/etc/hosts中即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#Pixiv Start127.0.0.1 pixiv.net 127.0.0.1 www.pixiv.net 127.0.0.1 ssl.pixiv.net127.0.0.1 accounts.pixiv.net 127.0.0.1 touch.pixiv.net127.0.0.1 oauth.secure.pixiv.net127.0.0.1 dic.pixiv.net127.0.0.1 en-dic.pixiv.net 127.0.0.1 sketch.pixiv.net127.0.0.1 payment.pixiv.net127.0.0.1 factory.pixiv.net 127.0.0.1 comic.pixiv.net 127.0.0.1 novel.pixiv.net 127.0.0.1 imgaz.pixiv.net 127.0.0.1 sensei.pixiv.net127.0.0.1 fanbox.pixiv.net127.0.0.1 source.pixiv.net127.0.0.1 i1.pixiv.net 127.0.0.1 i2.pixiv.net 127.0.0.1 i3.pixiv.net 127.0.0.1 i4.pixiv.net127.0.0.1 hls1.pixivsketch.net127.0.0.1 hls2.pixivsketch.net127.0.0.1 hls3.pixivsketch.net127.0.0.1 hls4.pixivsketch.net127.0.0.1 hls5.pixivsketch.net127.0.0.1 hls6.pixivsketch.net127.0.0.1 hls7.pixivsketch.net127.0.0.1 hls8.pixivsketch.net127.0.0.1 hls9.pixivsketch.net127.0.0.1 hls10.pixivsketch.net127.0.0.1 hls11.pixivsketch.net127.0.0.1 hls12.pixivsketch.net127.0.0.1 hls13.pixivsketch.net127.0.0.1 hls14.pixivsketch.net127.0.0.1 hls15.pixivsketch.net127.0.0.1 hls16.pixivsketch.net127.0.0.1 hls17.pixivsketch.net127.0.0.1 hls18.pixivsketch.net127.0.0.1 hls19.pixivsketch.net127.0.0.1 hls20.pixivsketch.net127.0.0.1 hlsa1.pixivsketch.net127.0.0.1 hlsa2.pixivsketch.net127.0.0.1 hlsa3.pixivsketch.net127.0.0.1 hlsa4.pixivsketch.net127.0.0.1 hlsa5.pixivsketch.net127.0.0.1 hlsa6.pixivsketch.net127.0.0.1 hlsa7.pixivsketch.net127.0.0.1 hlsa8.pixivsketch.net127.0.0.1 hlsa10.pixivsketch.net127.0.0.1 hlsa11.pixivsketch.net127.0.0.1 hlsa12.pixivsketch.net127.0.0.1 hlsa13.pixivsketch.net127.0.0.1 hlsa14.pixivsketch.net127.0.0.1 hlsa15.pixivsketch.net127.0.0.1 hlsa16.pixivsketch.net127.0.0.1 hlsa17.pixivsketch.net127.0.0.1 hlsa18.pixivsketch.net127.0.0.1 hlsa19.pixivsketch.net127.0.0.1 hlsc1.pixivsketch.net127.0.0.1 hlsc2.pixivsketch.net127.0.0.1 hlsc3.pixivsketch.net127.0.0.1 hlsc4.pixivsketch.net127.0.0.1 hlsc5.pixivsketch.net127.0.0.1 hlsc6.pixivsketch.net127.0.0.1 hlse1.pixivsketch.net127.0.0.1 hlse2.pixivsketch.net127.0.0.1 hlse3.pixivsketch.net127.0.0.1 hlse4.pixivsketch.net127.0.0.1 hlse5.pixivsketch.net127.0.0.1 hlse6.pixivsketch.net127.0.0.1 hlse7.pixivsketch.net127.0.0.1 hlse8.pixivsketch.net127.0.0.1 hlse9.pixivsketch.net127.0.0.1 hlst1.pixivsketch.net127.0.0.1 i.pximg.net127.0.0.1 app-api.pixiv.net 13.226.113.16 g-client-proxy.pixiv.net 210.140.131.159 d.pixiv.org 210.140.92.140 pixiv.pximg.net 210.140.92.139 s.pximg.net210.140.131.246 api.booth.pm210.140.131.220 myaccount.pixiv.net#Pixiv End# 顺手修一下维基百科# Wikipedia Start127.0.0.1 en.wikipedia.org127.0.0.1 zh.wikipedia.org #中文维基百科桌面版127.0.0.1 en.m.wikipedia.org127.0.0.1 zh.m.wikipedia.org127.0.0.1 zh-yue.wikipedia.org #粤文维基百科桌面版127.0.0.1 wuu.wikipedia.org #吴语维基百科桌面版127.0.0.1 ug.wikipedia.org #维吾尔文维基百科桌面版127.0.0.1 ja.wikipedia.org #日文维基百科桌面版127.0.0.1 zh.wikinews.org #中文维基新闻桌面版# Wikipedia End# Wikimedia Start127.0.0.1 wikimedia.org127.0.0.1 upload.wikimedia.org# Wikimedia End 然后浏览器就可以直接上pixiv啦！ ps：安卓/苹果客户端可以使用pixez","path":"2020/10/18/2020-10-18/ubuntu上安装pixiv-nginx/","date":"10-18","excerpt":"","tags":[{"name":"pixiv","slug":"pixiv","permalink":"https://fnsflm.xyz/tags/pixiv/"},{"name":"nginx","slug":"nginx","permalink":"https://fnsflm.xyz/tags/nginx/"},{"name":"安装配置","slug":"安装配置","permalink":"https://fnsflm.xyz/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"python生成可执行文件","text":"python生成可执行文件下载pyinstaller 1pip install pyinstaller 以python文件123.py为例，终端输入 1pyinstaller -F 123.py 完成！ 如果发生报错：maximum recursion depth exceeded，参考文章python maximum recursion depth exceeded 处理办法 终端输入 1pyi-makespec -F 123.py 123.spec插入下面两行： 12import syssys.setrecursionlimit(50000) 终端输入 1pyinstaller -F 123.spec 在这最后一步，我还碰到了错误： 12345678Unable to find \"/usr/include/python3.6m/pyconfig.h\" when adding binary and data files.This would mean your Python installation doesn'tcome with proper library files. This usually happens by missing developmentpackage, or unsuitable build parameters of Python installation.* On Debian/Ubuntu, you would need to install Python development packages * apt-get install python3-dev * apt-get install python-dev* If you're building Python by yourself, please rebuild your Python with`--enable-shared` (or, `--enable-framework` on Darwin) 按照提示的下载： 12sudo apt-get install python3-dev sudo apt-get install python-dev 再次执行 1pyinstaller -F 123.spec over! ps：在linux系统上打包就是没有后缀名的二进制文件，在windows下打包就是exe文件，pyinstall做了环境的处理","path":"2020/10/10/2020-10-10/python生成可执行文件/","date":"10-10","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://fnsflm.xyz/tags/python/"}]},{"title":"ubuntu开机提示错误locale-check: 没有那个文件或目录","text":"ubuntu开机提示错误locale-check: 没有那个文件或目录开机时发现了这个错误 参考：bash: /usr/bin/locale-check: No such file or directory error after i downgraded from ubuntu 18.10 to 18.04 按这篇文章的回答就能解决，大体思路是，base-files包出了问题，然后通过apt-cache policy base-files_ 1apt-cache policy base-files 其实看到这里我明白了，是我之前下载deepin-wine时残留下来的问题 123456apt download base-files=10.1ubuntu2.2apt download base-files=10.1ubuntu2.10apt download base-files=10.1ubuntu2dpkg -c base-files_10.1ubuntu2.2_amd64.deb | grep \"/usr/bin\"dpkg -c base-files_10.1ubuntu2.10_amd64.deb | grep \"/usr/bin\"dpkg -c base-files_10.1ubuntu2_amd64.deb | grep \"/usr/bin\" 在2.10版本里找到了locale-check 安装就好 1sudo dpkg -i base-files_10.1ubuntu2.10_amd64.deb 但是，如果在之后安装其它软件是使用了apt upgrade那么又会按回原来的版本，而locale-check会被删除，所以要把local-check备份一下 123cp /usr/bin/locale-check ./sudo apt upgradesudo cp ./locale-check /usr/bin/locale-check over！","path":"2020/10/07/2020-10-7/ubuntu开机提示错误locale-check:没有那个文件或目录/","date":"10-07","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://fnsflm.xyz/tags/linux/"},{"name":"bug","slug":"bug","permalink":"https://fnsflm.xyz/tags/bug/"}]},{"title":"linux安装latex","text":"linux安装latex环境 linux ubuntu 18.04 LTS perl 5.26.1 安装texlive关于版本的选择，我看到有说用ctex的，然后到官网上一看更新记录，最新的维护是在12年3月，8年无人问津，就可以直接pass了 参考： linux下安装texlive2017 到官网上下载texlive 英文说的很清楚了，下载其它版本 下载后解压缩，终端cd到解压缩的路径下，执行 1sudo ./install-tl 执行后会问要执行的操作，按i执行 下载时间要一个小时，下载过程会显示要多长时间，看到welcome to latex说明安装成功 设置环境变量： 123export MANPATH=${MANPATH}:/usr/local/texlive/2020/texmf-dist/doc/man/export INFOPATH=${INFOPATH}:/usr/local/texlive/2020/texmf-dist/doc/info/export PATH=${PATH}:/usr/local/texlive/2020/bin/x86_64-linux/ 测试下环境变量是否正确： vim test.txt 1234\\documentclass{article}\\begin{document}hello \\LaTeX\\end{document} 执行： 1xelatex test.txt 安装texstudio到官网上下载texstudio 下载后用dpkg安装即可 1sudo dpkg -i texstudio_3.0.1-1+2.1_amd64.deb 成功！ 注：这里选用的版本是xubuntu，我使用的是gubuntu，但并有出现缺失依赖的情况。因为没有找到对应的版本，我先下的是AppImage，但效果并不怎么好，在选项栏停留时会出现黑框框，而正常的应该是黄框框+解释说明的英文。 报错 参考：确认已经安装了某个 (La)TeX 发行版例如 MiKTeX 或 TeX Live，并且已经在命令配置页设置了正确的路径，解决办法 载入刚刚测试的test.txt运行发生报错 12Make sure that you have installed a (La)TeX distribution e.g. MiKTeX or TeX Live, and have set the correct paths to this distribution on the command configuration page.A (La)TeX editor like TeXstudio cannot work without the (La)TeX commands provided by such a distribution. 点击 会发现前四个都是&lt;unknown&gt;，在/usr/local/texlive/2020/bin/x86_64-linux/下对应的有，加进去就行了 如果不太确定位置，使用find命令搜索，比如 1find /usr/local/texlive/ -iname pdflatex 成功！","path":"2020/10/05/2020-10-5/linux安装latex/","date":"10-05","excerpt":"","tags":[]},{"title":"禁用键盘上的按键","text":"禁用键盘上的按键我的键盘方向键是这样的 按左右键的时候总是按错就很烦，所以就查了下怎样禁用按键 参考 linux下屏蔽键盘按键 先用xev来查看目标按键的keycode，终端中输入xev后随着你按不同的键，就会弹出对应的keycode 我这里PgUp是112，PgDn是117 使用xmodmap更改映射关系 12345xmodmap -pke &gt; ~/.xmodmap cp ~/.xmodmap ~/.xmodmap.backvim ~/.xmodmap # 更改keycode 112，keycode117等号后的全删了xmodmap -e \"clear Lock\" xmodmap ~/.xmodmap 这就完成了按键的屏蔽，但这是一次性的，重启之后就会失效 开机自启动 这个开机自启动说起来都是泪，试过chkconfig发现ubuntu已经不支持了，然后用systemd然后发现xsever好像不支持，报错有unable to open display或者No protocol specified 参考Ubuntu 18.04开机启动键盘映射的方法，最后用gnome自带的工具得到解决 终端输入： 1gnome-session-properties 点击添加，名称和注释随便填，命令为 1/bin/bash -c \"sleep 30; xmodmap -e \\\"keycode 112 =\\\" ; xmodmap -e \\\"keycode 117 =\\\"; notify-send \\\"auto_ban_pupd\\\" \\\"finished\\\"\" 附上未转义的代码 12345#!/bin/bash -csleep 30;xmodmap -e \"keycode 112 =\" ; xmodmap -e \"keycode 117 =\";notify-send \"auto_ban_pupd\" \"finished\"; 然后原文里写的是xmodmap ~/.xmodmap，这个我亲自试过，会有短暂的卡顿现象，所以用xmodmap -e会快许多，notify-send会在你的通知栏显示成功了","path":"2020/10/05/2020-10-5/禁用键盘上的按键/","date":"10-05","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://fnsflm.xyz/tags/linux/"},{"name":"x.org","slug":"x-org","permalink":"https://fnsflm.xyz/tags/x-org/"}]},{"title":"推荐一款图片压缩工具","text":"推荐一款图片压缩工具网址：tinypng 支持jpg和png的压缩，压缩后的画质也相当好 不支持设定压缩的质量，不支持过大图片的压缩（这种情况推荐推荐使用giftofspeed tool） 下面附上使用python调用tinypng提供的api进行压缩图片 pip下载： 1pip install tinify python代码： 12345678#!usr/bin/python3#-*- coding:utf-8 -*- import tinifytinify.key = \"nj8MLK2tCHJ5xr5SlvjtZBlmz7yvRZFH\"source = tinify.from_file(\"original-z46.jpg\") # 14.0M# source=tinify.from_url(\"https://i.loli.net/2020/10/02/gHjcZawdAbJQxi1.jpg\")source.to_file(\"little-z46.jpg\") 具体可以看API Reference，这里的api key是要申请的，也不麻烦，一个邮件的事儿。（只是玩玩就用我的key也没关系） 附上little-z46.jpg (812.5K)","path":"2020/10/02/2020-10-2/推荐一款图片压缩工具/","date":"10-02","excerpt":"","tags":[]},{"title":"ubuntu安装植物大战僵尸","text":"ubuntu安装植物大战僵尸国庆放假，突然想玩植物大战僵尸了，就装了一下 环境 Linux ubuntu 18.04LTS deepin-wine 下载植物大战僵尸 原贴： https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1207851 链接: https://pan.baidu.com/s/1SZ-W_JElScWjffL6ZeUB5w 提取码: 6r8q 下载后直接使用dpkg安装即可 12sudo dpkg -i植物VS僵尸deepin版.debsudo apt update 如果没有显示缺失依赖包(已经装了deepin-wine)，那么就可以直接玩了 我是用find找到游戏在哪儿的，我的在/opt/apps/plantsvszombies文件夹中，运行files/run.sh即可 安装deepin-wine如果上一步游戏已经能正常运行，那就可以忽视这一步 参考：https://blog.csdn.net/weixin_42592666/article/details/108384719 将这个网址里的deb包全部下载下来即可 http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/ 1234567891011121314151617181920212223echo \"deb [trusted=yes] http://mirrors.aliyun.com/deepin stable main contrib non-free\" | sudo tee /etc/apt/sources.list.d/deepin.listsudo apt updatewget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-fonts-wine_2.18-18_all.deb wget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-fonts-wine_2.18-22~rc0_all.deb wget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-libwine-dbg_2.18-18_i386.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-libwine-dbg_2.18-22~rc0_i386.deb wget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-libwine-dev_2.18-18_i386.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-libwine-dev_2.18-22~rc0_i386.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-libwine_2.18-18_i386.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-libwine_2.18-22~rc0_i386.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-wine-binfmt_2.18-18_all.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-wine-binfmt_2.18-22~rc0_all.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-wine32-preloader_2.18-18_i386.deb wget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-wine32-preloader_2.18-22~rc0_i386.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-wine32-tools_2.18-18_i386.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-wine32-tools_2.18-22~rc0_i386.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-wine32_2.18-18_i386.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-wine32_2.18-22~rc0_i386.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-wine_2.18-18_all.debwget http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin-wine/deepin-wine_2.18-22~rc0_all.debsudo dpkg -i *.debsudo apt updatesudo apt -f install","path":"2020/09/30/2020-9-30/ubuntu安装植物大战僵尸/","date":"09-30","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://fnsflm.xyz/tags/linux/"},{"name":"安装配置","slug":"安装配置","permalink":"https://fnsflm.xyz/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"wine","slug":"wine","permalink":"https://fnsflm.xyz/tags/wine/"}]},{"title":"linux中的查找","text":"linux中的查找[持续更新] 文件查找 find 文件查找find 帮助文档 Finding Files 12345678910111213141516# 常用find [path] -name [filename] # 查找[path]下[filename]文件find [path] -iname [filename] # 忽略大小写的查找find [path] -maxdepth [num] -name [filename] # -maxdepth +数字为搜索的最大层数find [path] -not -name [filename] # 查找不匹配的，同 find [path] ! -name [filename]find [path] -name [filename1] -name [filename2] # 多条件查找find [path] -type d -name [dirname] # 查找目录find [path] -type d -empty # 查找空目录find [path] -size [size] # 查找文件大小大于/大于/等于size的 # 进阶用法find [path] -maxdepth [num] -maxdepth [num2] -name [filename] # 设置查找的最大深度和最小深度find [path] -c[dimension] [num] # 查找符合条件修改时间的文件find [path] -perm [permision] # 查找文件中符合权限的文件find [path] [...] -exec [bash instruction] {} \\; # 对查找出的符合条件的文件进行批处理操作# tipsfind [path] [...] |wc -l # 查看有多少条记录 详细说明 12# 查找[path]下[filename]文件find [path] -name [filename] [path]可以是相对路径可以是绝对路径，也可以是多条路径，[filename]是完全匹配，不是包含子字符串就能匹配成功的，可以使用通配符*，如果命令较为简单，[filename]可以不用加表示字符串的双引号，参数过多会出现识别不了的问题，此时要加上双引号。 最大深度设为1的话还可以使用ls+grep：ls /etc | grep conf，除了maxdepth，还有mindepth，用法一样，如果要查找第n层的结果，让最大深度和最小深度的值一样即可 12# -maxdepth +数字为搜索的最大层数find [path] -maxdapth [num] -name [filename] 12# 查找目录find [path] -type d -name [dirname] 如果一个路径的几层都能和[dirname]匹配，那这几层都会在结果中分条显示出来 type后能接的类型： f 普通文件 d 目录 l 符号连接 b 块设备 s 套接字 匹配多种类型的话用逗号隔开 12# 多条件查找find [path] -name [filename1] -name [filename2] 两个-name之间什么都不加，默认是AND与操作，如果用OR或操作，加上-o 12# 查找文件大小大于/大于/等于size的find [path] -size [size] [size]前不带符号（没有“=”号）如果文件使用[size]个单位的空间（向上取整），则为true，数字前加上“+”号，表示如果文件使用至少n个存储单元，“-”号表示文件使用少于n个存储单元 [size]数字后不带字母，默认是512字节块，后面可以带上如下单位（区分大小写）： b（小写），512字节 c（小写），1字节 w（小写），2字节 k（小写），KB M（大写），MB G（大写），GB 12# 查找文件中符合权限的文件find [path] -perm [permision] linux中权限表示有两种，一种是用数字表示，读权限是4，写是2，执行是1，具有哪个权限加起来就行，比如读写可执行是7，读写是6，读可执行是5。而linux针对不同的用户（user,group,others）又分别赋予权限，所以会看到三个数字，比如777,664等。 另一种是用字母表示，ugo分别代表user,group,others，a则代表所有人。rwx代表读、写、可执行。 在表示权限的字母/数字前如果什么都不加就是精确匹配，而加上短横线-代表含有表示的权限就能匹配，而/代表三个用户中有一个满足即可（无权限除外） 做一个简单的小实验，先用bash生成不同权限的文件，忽略others，生成权限不同的16个文件 1234567891011121314for i in {1..16}do touch \"$i.txt\" chmod 000 \"$i.txt\"donepm=(0 4 2 6)for i in {0..3}do for j in {0..3} do name = `expr $i \\* 4 + $j + 1` chmod \"${pm[i]}${pm[j]}\" \"${name}.txt\" donedone 依次执行下面三条命令，为了看的更清楚，使用了-exec，将find的结果用ls -l显示出来，这里的[path]没有用.或者./，是因为会find到.这个目录本身，而目录能正常访问，至少要具有500的权限，所以采用了./*的写法。结果已经很清晰明了了。 123find ./* -perm 420 -exec ls -l {} \\;find ./* -perm -420 -exec ls -l {} \\;find ./* -perm /420 -exec ls -l {} \\;","path":"2020/09/28/2020-9-28/linux中的查找/","date":"09-28","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://fnsflm.xyz/tags/linux/"}]},{"title":"推荐github状态卡片","text":"推荐github状态卡片前言在github上, 创建与用户名同名的仓库时, 该仓库的README会作为personal profile展示出来, 我们经常看到许多人的主页里会有这样的自我介绍, 以及一些统计的小卡片: 这些小卡片是通过github action来制作的, 统计个人的star, commit, issus等信息,展示给别人看 上图的卡片来自项目: https://github.com/anuraghazra/github-readme-stats, 我也曾试着配过, 可以看视频: https://www.youtube.com/watch?v=n6d4KHSKqGk&amp;t=302s 跟着做 今天, 我要介绍的是另一种小卡片, 有各种各样的插件, 可以按照自己的喜好展示不同的内容, 功能丰富,项目地址: https://github.com/lowlighter/metrics 我的状态卡片( github地址: https://github.com/fnsflm/): 介绍项目地址: https://github.com/lowlighter/metrics 通过github action能在每次提交(git push)后, 自动生成卡片, 不仅限于profile readme, 也可展示到其它你想展示的地方. 这些卡片也完全可以分开生成, 比如Website performances, Music plugin等可以在github外单独展示 基本卡片: 有下面两种, 有对于账户和组织的, 统计了各种信息, 如图所示 21个插件: 扩展统计了各种信息, 比如github提交情况, 使用的程序语言占比, 个人网址的评测等, README里有详细的介绍 3种模板(外观): 使用项目里的README说的十分清楚, 这里只做一些举例和自己碰到的一些坑 如果只需要最基础的卡片,而不需要扩展的插件, 可以这样生成: 1![Metrics](https://metrics.lecoq.io/my-github-user) 比如我的是: https://metrics.lecoq.io/fnsflm 如果考虑添加插件, 更改模板(templates), 那么需要使用github action 首先要获取personal token settings–&gt; developer settings personal access tokens –&gt; generate token 名字(Note)随意, 不需要勾选任何选项, 然后点下方的Generate token即可. github token只会显示一次, 复制后保存好, 离开页面后不会再显示出token 在想要存卡片图的项目里, 往往是my-github-user/my-github-user, 比如我的是fnsflm/fnsflm, 的setting中: settings –&gt; secrets –&gt; new repository secret 名字随意, 但是要写入action的, value是刚刚复制的token, 这里以METRICS_TOKEN 为例 在项目.github/workflows/下新建action.yml配置文件: 123456789101112131415161718name: Metricson: # 一小时执行一次action schedule: [{cron: \"0 * * * *\"}] # 每次提交执行action push: {branches: [\"master\", \"main\"]} workflow_dispatch:jobs: github-metrics: runs-on: ubuntu-latest steps: # 仓库位置, 可以fork后用自己的仓库 - uses: lowlighter/metrics@latest with: # GitHub token token: ${{ secrets.METRICS_TOKEN }} # GITHUB_TOKEN is a special auto-generated token restricted to current repository, which is used to push files in it committer_token: ${{ secrets.GITHUB_TOKEN }} 提交后会执行action, 在项目下生成svg图片(5 - 10min), 扩展插件根据README里插件说明, 并排着committer_token顺着添加即可: 然后README.md引用即可展示: 1![METRICS](https://github.com/my-github-user/my-github-user/blob/main/github-metrics.svg) 比如我的: 12![Metrics](https://github.com/fnsflm/fnsflm/blob/main/github-metrics.svg)![Metrics](https://cdn.jsdelivr.net/gh/fnsflm/fnsflm/github-metrics.svg) 我的action配置: https://github.com/fnsflm/fnsflm/blob/main/.github/workflows/action.yml 单个卡片(举例) 12345678910- uses: fnsflm/metrics@latest with: filename: pagespeed.svg committer_token: ${{ secrets.GITHUB_TOKEN }} token: ${{ secrets.METRICS_TOKEN }} plugin_pagespeed_token: ${{ secrets.PAGESPEED_TOKEN }} base: \"\" plugin_pagespeed: yes plugin_pagespeed_url: https://fnsflm.xyz plugin_pagespeed_screenshot: yes 这里以Website performances为例加上base:\"\"即可生成单独卡片, 最好能给生成的图片命名filename: pagespeed.svg","path":"2020/09/27/2021-02-17/推荐github状态卡片/","date":"09-27","excerpt":"","tags":[{"name":"github","slug":"github","permalink":"https://fnsflm.xyz/tags/github/"},{"name":"github action","slug":"github-action","permalink":"https://fnsflm.xyz/tags/github-action/"}]},{"title":"vscode快速配置调试c++","text":"vscode快速配置调试c/c++ 前言 生成task.json、launch.json文件 修改launch.json 修改task.json 最后 前言想当初刚刚学c语言时，看中了vscode编辑器，比dev-c++好用多了，但c/c++配置文件在网上到处抄过来都不对的痛苦我还历历在目。现在对各方面理解都更深了，所以写一下这篇文章 事先声明一下，vscode的版本在变，json文件的格式写法也在变，所以这里仅仅作为参考。如果在网上到处看的配置配不对的话，最后的办法就是到官网上看说明文档。 生成task.json、launch.json文件首先要将你代码文件所在的文件夹在vscode中打开，不然是没法调试的 然后在左侧一栏中的调试中点击调试和运行 然后点解c++(GDB/LLDB)，g++ 生成调试活动文件，然后不用管它运行了啥，直接点开.vscode文件夹，修改task.json，lauch.json。其实，如果版本对应的话，从网上抄的这两个文件，然后按照正确的目录格式复制粘贴下来再改也是可以的(不用c++(GDB/LLDB)，g++ 生成调试活动文件这两步了)。 修改launch.json修改过程是一步一步的，如果这过程中你能调试了，那你就不用改了。当然，可能一开始什么都不用改就是对的。 这个里面最可能出错的是带有$+大括号的各种变量 这是最开始新生成的launch.json 最重要的是“program”参数，需要修改为你生成可执行文件的绝对路径(至少我用相对路径是失败了的) 然后“cwd”的参数是工作路径，也就是你当代码文件所在的路径，一般不会出问题，出问题了就都修改一遍 这是我的launch.json 修改task.json新生成的task.json task.json一般不修改就能正常运行了。“cwd”就不用说了，“args”里的其实懂一点g++命令的一眼就看出来了，不懂的自行百度，如果要链接库或者其它选项按照格式往下加就行了 这里给出我的作为参考： 其中“lmysqlclient”是调用mysql C api所需的库 最后以上说的一个c/c++文件配置调试，加入一个文件夹有多个c++要调试而又不愿意调试一个文件改一次，那么，json文件中的变量$+大括号的含义就要搞清楚然后再写，当然，要是网上抄到了正确的json文件那自然更好Variables Reference 官方文档说的已经相当详细了，如果网上的抄不对那就多读读官方文档吧。","path":"2020/09/26/2020-9-26/vscode快速配置调试c++/","date":"09-26","excerpt":"","tags":[{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"vscode","slug":"vscode","permalink":"https://fnsflm.xyz/tags/vscode/"},{"name":"安装配置","slug":"安装配置","permalink":"https://fnsflm.xyz/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"ubuntu上配置odbc","text":"ubuntu上配置odbc 安装odbc 安装mysql驱动 配置mysql驱动 配置odbcinst.ini 配置odbc.ini 参考： ubuntu安装odbc及（mysql驱动） 安装odbc12apt-get install unixodbcapt-get install unixodbc-dev 安装mysql驱动1apt-get install libmyodbc 报错： 只能到mysql官网上下载驱动MySQL Community Downloads 这里会犯难，下载哪个好，点击右边的帮助，可以查看文档： 4.2.3 Installing Connector/ODBC from a DEB Distribution 文档里说的很清楚了，我们只需要下载两个 12sudo dpkg -i mysql-connector-odbc_8.0.21-1ubuntu18.04_amd64.debsudo dpkg -i mysql-connector-odbc-setup_8.0.21-1ubuntu18.04_amd64.deb 配置mysql驱动配置odbcinst.ini我这里deb下载完后的/etc/odbcinst.ini已经自动配置好了 这里给出我的配置 1234567[MySQL ODBC 8.0 Unicode Driver]Driver=/usr/lib/x86_64-linux-gnu/odbc/libmyodbc8w.soUsageCount=1 [MySQL ODBC 8.0 ANSI Driver] Driver=/usr/lib/x86_64-linux-gnu/odbc/libmyodbc8a.so UsageCount=1 配置odbc.ini1234567[NAME]Driver = /usr/lib/x86_64-linux-gnu/odbc/libmyodbc8a.soSERVER=localhostPORT=3306DATABASE=YOURDATABASEUSER=rootPASSWORD=root 中括号NAME随便输就行，方便管理最好输入数据库的名字，DATABASE也要事先建立好，账号密码写上数据库的账号密码 测试连接数据库： 1isql -v NAME 配置成功！","path":"2020/09/25/2020-9-25/ubuntu上配置odbc/","date":"09-25","excerpt":"","tags":[{"name":"安装配置","slug":"安装配置","permalink":"https://fnsflm.xyz/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"数据库","slug":"数据库","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"https://fnsflm.xyz/tags/mysql/"}]},{"title":"ubuntu上c++使用mysql接口调用数据库","text":"ubuntu上c++使用mysql接口调用数据库c++ 连接mysql有两种方法，一种是通过odbc调用，另一种是通过mysql提供的c api进行调用 我才不是把两种方法搞混了稀里糊涂装了odbc却抄的mysql c api的代码呢 参考： Linux下C++访问MySQL数据库 首先要安装libmysql++库： 1sudo apt-get install libmysql++-dev 代码示例： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;mysql/mysql.h&gt;#include &lt;cstdlib&gt;using namespace std;int main(int argc, char const *argv[]){ MYSQL mysql; mysql_init(&amp;mysql); // 函数mysql_real_connect建立一个数据库连接 mysql = *mysql_real_connect(&amp;mysql, \"127.0.0.1\", \"root\", \"root\", \"blhxbot\", 0, NULL, 0); // mysql_query()执行成功返回0，失败返回非0值 mysql_query(&amp;mysql, \"show tables\"); MYSQL_RES *result; // 获取结果集 result = mysql_store_result(&amp;mysql); // mysql_num_fields()返回结果集中的字段数 while(MYSQL_ROW row = mysql_fetch_row(result)) { for (int j = 0; j &lt; mysql_num_fields(result); j++) { cout &lt;&lt; row[j]&lt;&lt;\" \"; } cout &lt;&lt; endl; } mysql_close(&amp;mysql); return 0;} 原文 Linux下C++访问MySQL数据库中，mysql_field_count表示的是列数，而mysql_fetch_row取出的一整行，包括所有列，故mysql_field_count不能作为循环的指标。使用while循环可取出每一行。 注：g++编译时要链接库，否则会报错 12g++ new_cpp.cpp -o new_cpp -lmysqlclient./new_cpp","path":"2020/09/25/2020-9-25/ubuntu上c++使用mysql接口调用数据库/","date":"09-25","excerpt":"","tags":[{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"数据库","slug":"数据库","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"https://fnsflm.xyz/tags/mysql/"}]},{"title":"安装tensorflow-gpu","text":"安装tensorflow-gpu系统环境 操作系统：Linux Ubuntu 18.04 LTS python版本： 3.6.9 GPU：NAVIDIA GeForce 940MX 注意！ 在安装tensorflow和cuda之前一定要注意版本的对应，具体对应关系在经过测试的构建配置（本人踩过的坑，这里使用的版本仅仅做示例，要改成对应的版本） cuda选择版本安装时，一定要选择local版本，不要选择network版本 安装cuda 参考： Ubuntu16.04+CUDA9.0 安装（全网最简便快速安装，测试成功） 下载deb安装包在英伟达官网下载cuda，选择适合的版本，我选择的是10.1版，接下来根据自己的系统一步一步的点： 安装cuda代码在官网已经给出，依次执行即可，时间有些长,复制官网的代码来执行1234sudo dpkg -i cuda-repo-ubuntu1804_10.1.105-1_amd64.debsudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pubsudo apt-get updatesudo apt-get install cuda 安装好后可以用命令sudo apt autoremove卸载下载完成后不再需要的软件包（非必须） 配置环境变量 打开/etc/profile，记得要有修改权限sudo vim /etc/profile，添加： 12export PATH=/usr/local/cuda-11.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-11.0/lib64:$LD_LIBRARY_PATH 不确定路径的话ls找一找就好其实这里挺奇怪的，我官网上点的是10.1版本，可这里怎么变成11.0了。可能是因为我使用的网络安装，添加源后使用的apt去下载，这时下载的会时默认的最新版。最后source /etc/profile更新配置tips:有的人会在~/.bashrc中配置终端的颜色，而执行source /etc/profile后，hostname可能会变成白色，此时，只用再执行source ~/.bashrc即可恢复（导入的环境变量依然有效） 验证安装执行nvcc -V验证安装是否成功： 安装cudnn 参考 CUDA与cuDNN官网上下载https://developer.nvidia.com/rdp/cudnn-download，选择之前下载的cuda对应版本即可，但要事先注册账户和填一个调查问卷，照着流程走即可下载Library，我选择第一个下载完后，解压，里边有include,lib64两个文件夹，复制到之前下载的cuda对应的目录中即可 1234567cd ~/下载tar -xvf cudnn-11.0-linux-x64-v8.0.3.33.tgzcd cudnn-11.0-linux-x64-v8.0.3.33/cudasudo cp include/cudnn.h /usr/local/cuda-11.0/include/sudo cp lib64/libcudnn* /usr/local/cuda-11.0/lib64/sudo chmod a+r /usr/local/cuda-11.0/include/cudnn.hsudo chmod a+r /usr/local/cuda-11.0/lib64/libcudnn* 这样就安装完了其实在找cuda文件夹时会发现/usr/local下有cuda和cuda-11.0但通过ls -l命令列出后可以发现这是个链接,所以不用担心,复制到cuda或者cuda-11.0里都是有效的 安装tensorflow-gpu终端中输入： 1pip install tensorflow-gpu==2.3.0 ==后写合适的版本，tensorflow-gpu 2.3.0对应的cuda是10.1,所以我这里发生了报错: 通过降低cuda版本，程序问题解决，安装成功，可以参考这篇文章tensorflow-gpu报错“Could not load dynamic library ‘libcudart.so.10.1’”","path":"2020/09/22/2020-9-22/安装tensorflow-gpu/","date":"09-22","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://fnsflm.xyz/tags/python/"},{"name":"安装配置","slug":"安装配置","permalink":"https://fnsflm.xyz/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"tenserflow","slug":"tenserflow","permalink":"https://fnsflm.xyz/tags/tenserflow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://fnsflm.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"tensorflow-gpu报错“Could not load dynamic library 'libcudart.so.10.1'”","text":"问题描述 原因 踩坑 cuda安装时选择了network网络版本 问题描述在安装好tensorflow、cuda和cudnn后，在python中import tensorflow时仍然发生报错： 原因这里是cuda版本不对的问题，我安装的是11.0版本，而需要的是10.1，所以在安装tensorflow之前，一定要确认tensorflow和cuda版本的对应！！ 踩坑cuda安装时选择了network网络版本 安装好后看看软件包里有什么版本： 发现都是11.0版本我安的明明是10.1deb包，你给我安11.0，这不坑人吗 卸载cuda12sudo apt remove --purge cudasudo apt autoremove 在看看是否卸载干净了ls /usr/local/|grep cuda: 还剩下一个cuda-11.0文件夹，原来的cuda软连接已经没有了，再看看这个文件夹里还剩啥tree /usr/local/cuda-11.0： 这些不是之前复制的cudnn的文件吗？那直接删掉就好sudo rm -rf /usr/local/cuda-11.0再看看还有没有剩的，输入dpkg --get-selections |grep cuda查看：显示deinstall说明还有配置文件残留，一个个清除即可： 123sudo dpkg -P cuda-cudart-11-0sudo dpkg -P cuda-toolkit-11-0sudo dpkg -P cuda-visual-tools-11-0 好了，这次是彻彻底底删完了！ 安装cuda10.1一定不能选择network版！！其它教程也有选择runfile(local)，似乎也行下载完成后，在下载的目录下执行：123sudo dpkg -i cuda-repo-ubuntu1804-10-1-local-10.1.105-418.39_1.0-1_amd64.debsudo apt updatesudo apt install cuda 下载开始前会有个确认的输入，这里先看看安装的包是不是10.1的然后环境变量就不说了，配置方法没有变，可以看ubuntu pip安装tensorflow-gpu","path":"2020/09/22/2020-9-23/tensorflow-gpu报错“Could-not-load-dynamic-library-libcudart-so-10-1-”/","date":"09-22","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://fnsflm.xyz/tags/python/"},{"name":"bug","slug":"bug","permalink":"https://fnsflm.xyz/tags/bug/"},{"name":"tenserflow","slug":"tenserflow","permalink":"https://fnsflm.xyz/tags/tenserflow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://fnsflm.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"cuda","slug":"cuda","permalink":"https://fnsflm.xyz/tags/cuda/"}]},{"title":"爱数社招新试题","text":"爱数社招新试题 Stolz定理的应用预备知识： 1.stolz定理 若数列{} {}满足{}严格单调递增且，且=L，(其中L可以为有限实数，也可以为),则=L 2.stolz定理 若数列{}{}满足{}严格单调递减且，且=L，(其中L可以为有限实数，也可以为),则=L 3.f(n)&gt;0,且极限存在的条件下，有f(n)= 习题(以下所有习题均不需要使用-N语言)1.求极限 2.=A，讨论下列四个式子的极限： (1) (2) (3) (4) 3.数列{} {}的极限分别为A，B求证： 4.若数列{}满足,求 5.若正数列{}满足,求极限 6.求极限：","path":"2020/09/20/2019-9-20/爱数社招新试题/","date":"09-20","excerpt":"","tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://fnsflm.xyz/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"尝试配置hadoop环境","text":"尝试配置hadoop环境系统环境 操作系统：linux ubuntu 18.04 LTS java: openjdk 11.0.8 安装hadoop我的电脑上已经配置好了java环境，这里就不详细说了，官网上可以下载的java的jdk源码包，下载后配置环境变量即可，而ubuntu有自带的openjdk，可以用apt工具直接下载在apache hadoop官网上下载适合的版本，可以参考Hadoop2与Hadoop3的区别 这里选择最新的3.1.4下载时间稍微有点长（可能是我网不好），下载后找个地方解压就好，很多教程里写的/usr/local/下，但个人因为权限的原因，不太喜欢存到这个目录下，自己找个地方存下了就是了，我存的地方是~/software配置环境变量vim ~/.bashrc修改.bashrc,$HADOOP_HOME就是解压后的文件夹的路径 1234export HADOOP_HOME=~/software/hadoop-3.1.4/export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoopexport YARN_CONF_DIR=$HADOOP_HOME/etc/hadoopexport PATH=$PATH:$HADOOP_HOME/bin 再输入source ~/.bashrc更新配置，hadoop version查看是否安装成功 单机配置 参考：Ubuntu16.04下Hadoop的本地安装与配置 默认情况下，Hadoop被配置成以非分布式模式运行的一个独立Java进程。这对调试非常有帮助。 下面的例子将已解压的$HADOOP_HOME/etc/hadoop/*.xml 作为输入（其它文本文件也行），查找并显示匹配给定正则表达式的条目。输出写入到指定的output目录。为了不污染源码，随便找个文件夹执行以下操作（大部分教程实在hadoop解压的文件夹下执行） 123mkdir inputcp $HADOOP_HOME/etc/hadoop/*.xml ./input hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output 'dfs[a-z.]+' 注： 目录下不能有output文件夹，否则会报错结果为：配置成功！ 伪分布配置ssh配置：如果ssh localhost能正常连接，如下图所示则可继续后续的步骤，其中可能出现报错：connect to host localhost port 22: Connection refused，此时使用apt重新下载ssh即可sudo apt-get install openssh-server，可以参考文章Ubuntu 安装配置SSH(ssh: connect to host localhost port 22: Connection refused问题的解决) 修改hadoop配置文件：配置文件在$HADOOPHOME/etc/hadoop文件夹下，要修改的是core-site.xml和hdfs-site.xml配置文件具体参数的说明可以参考：修改core-site.xml配置文件，修改hdfs-site.xml配置文件 core-site.xml: 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/tmp/hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml: 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/tmp/hadoop/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/tmp/hadoop/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改之后执行hadoop namenode -format格式化一个新的分布式文件系统，$HADOOP_HOME/sbin/start-dfs.sh来开启namenode和datanode执行时会发生报错：这个是ssh秘钥出现了问题，参考普通用户ssh免密登陆完美解决(Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password))这篇文章，在~/.ssh目录下执行cat ./id_rsa.pub &gt;&gt; ./authorized_keys再次执行$HADOOP_HOME/sbin/start-dfs.sh，仍然发生报错：此时需要修改配置文件hadoop-env.sh，最后一行添加（如果已经export JAVA_HOME则需要修改）： 1export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/ JAVA_HOME即为环境变量中的JAVA_HOME，如果已经配置但忘记在哪儿了可以在终端执行echo $JAVA_HOME获取再次执行$HADOOP_HOME/sbin/start-dfs.sh返回结果：再输入jsp列出了namenode和datanode说明配置成功","path":"2020/09/18/2020-9-18/尝试配置hadoop环境/","date":"09-18","excerpt":"","tags":[{"name":"安装配置","slug":"安装配置","permalink":"https://fnsflm.xyz/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"java","slug":"java","permalink":"https://fnsflm.xyz/tags/java/"},{"name":"大数据","slug":"大数据","permalink":"https://fnsflm.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hadoop","slug":"hadoop","permalink":"https://fnsflm.xyz/tags/hadoop/"}]},{"title":"尝试使用navicat","text":"尝试使用navicatNavicat 是一套快速、可靠并价格相宜的数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。它的设计符合数据库管理员、开发人员及中小企业的需要。Navicat 是以直觉化的图形用户界面而建的，让你可以以安全并且简单的方式创建、组织、访问并共用信息。 环境 linux ubuntu 18.04LTS mysql-5.7.31 navicat premium 学生认证 windows破解版可参考：Navicat介绍及安装 navicat的学生认证挺快的，只要你有学生邮箱，几乎立刻能注册学生认证链接没过多久就能在学生邮箱收到navicat的邮件，里面提供了激活码和下载地址： 里面提供了三种版本，其中有一个没有提供，但在官网上可以下载，关于版本的介绍可以看看navicat的简单介绍这篇文章，这里先只使用navicat premium，以后用过其它版本后再更新该博客 使用navicat premium 启动下载的是一个AppImage的可执行文件，双击即可运行可能会弹出这样奇怪的界面：此时，给文件一个可执行的权限即可解决勾选允许作为程序可执行文件，或者在终端中用chmod更改权限也行激活过程就不赘述了，启动成功： 连接数据库点击测试连接，出现权限不够的问题：解决方法其实很简单，把主机里的localhost改成127.0.0.1就可以解决，如果还无法解决，可以修改/etc/mysql/mysql.conf.d/mysqld.cnf中的配置，可以参考文章：2002 - Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (13 “权限不够”)然后就能正常使用了：连接服务器上的mysql 用mysql直接连接–大失败 查阅资料： 配置防火墙，开启80端口、3306端口 &amp; iptables 使用详解 连接远程mysql数据库失败常见原因及解决办法 没有找到办法，服务器mysql的权限全给了，mysql.user 的root-host也是允许所有的访问(%)，防火墙也允许了3306端口的连接，各种尝试无果，以待后续解决 使用ssh连接这么简单的办法我居然没有找到，整个晚上时间都浪费了，悲点击最上面一行的ssh，使用ssh连接服务器再设置数据库在服务器上的使用，这里的host就是本机了连接成功： over!可喜可贺","path":"2020/09/16/2020-9-16/尝试使用navicat/","date":"09-16","excerpt":"","tags":[{"name":"安装配置","slug":"安装配置","permalink":"https://fnsflm.xyz/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"数据库","slug":"数据库","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"navicat","slug":"navicat","permalink":"https://fnsflm.xyz/tags/navicat/"}]},{"title":"mysql数据库收集和导入数据集","text":"mysql数据库收集和导入数据集 环境 数据集的收集 数据集导入mysql数据库 环境linux ubuntu 18.04LTSmysql-5.7.31 数据集的收集 原贴【资源】史上最全数据集汇总 首先试了一下World Bank 下载该数据集时出现submit始终无法点的情况，以待解决 2. 再尝试RBI数据集 首页就能看到许多数据集，可以用chrome翻译成中文随便点一个： 点击pdf的图标，再点击pdf里的超链接，可以直接下载到数据集 随便下一个，数据集如图所示： 再将该表转为csv格式，方便后续数据库读取ELECT07022016_FEB18.csv 数据集导入mysql数据库 mysql小数类型的使用 原贴：SQL Server 小数类型（float 和 decimal） 在数据库中创建表 12345678910111213create table ELECT07022016_FEB18(data varchar(200), rtgs_vo decimal(10,2),rtgs_va decimal(10,2), neft_vo decimal(10,2),neft_va decimal(10,2), cts_vo decimal(10,2),cts_va decimal(10,2),imps_vo decimal(10,2),imps_va decimal(10,2), nach_vo decimal(10,2),nach_va decimal(10,2), upi_vo decimal(10,2),upi_va decimal(10,2), ussd_vo decimal(10,2),ussd_va decimal(10,2), dccp_vo decimal(10,2),dccp_va decimal(10,2),ppi_vo decimal(10,2),ppi_va decimal(10,2),mb_vo decimal(10,2),mb_va decimal(10,2),total_vo decimal(10,2),total_va decimal(10,2)); 查了下load data infile的用法，暂时没找到忽略最后几行的办法，因此使用了较大的varchar来存储第一格下图是看最长的一个有多少字符 看看创建的表 创建成功，然后感觉名字太复杂了，不好操作，改一下名： 1rename table ELECT07022016_FEB18 to eps_rd; 用load导入到数据库中 参考：mysql中的load data infile用法 1234load data infile '/home/hjy/桌面/everyday-learning2/2020-9-15/ELECT07022016_FEB18.csv' into table mysql_learning.eps_rd character set gb2312 fields terminated by ','; 出现报错： 参考：将csv 文件存入mysql 报错The MySQL server is running with the –secure-file-priv option so it cannot execute，显示secure_file_priv文件路径 1show variables like '%secure%'; 然后将文件拷贝至该路径下（文章中可以永久修改，解决该问题，但要重启mysql，为了简单起见，直接复制） 1sudo cp /home/hjy/桌面/everyday-learning2/2020-9-15/ELECT07022016_FEB18.csv /var/lib/mysql-files/ 再次导入，发生如下报错：参考：mysql 用load data 导入数据时，数据被截断问题 1set sql_mode=''; 再次运行，导入成功： 后续操作 删除为空的行 1delete from eps_rd where data=''; 拆分表 12create table month_eps as (select * from eps_rd where data like '___-%');delete from month_eps where data='Feb-18'; 把18年每天的数据分出来还有点麻烦，这里用了正则表达式 参考：MySQL正则表达式 1234create table feb_esp as select * from eps_rd where data regexp '^[0-9]' and data not like '_.%'; 再将其它信息存起来 1create table note as select data from eps_rd where data like '____%' and data not like '___-__'; 最后，我想给更改一下列名，把data改成notes可在网上没查到方法（好多写的是用sp_name更改，但我不会用），说来惭愧。我的java IDE：IntelliJ IDEA里有连结数据库的功能，然后用里面的工具成功更改列名。 1alter table note change data notes varchar(200) null; over！","path":"2020/09/15/2020-9-15/mysql数据库收集和导入数据集/","date":"09-15","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"https://fnsflm.xyz/tags/mysql/"}]},{"title":"数据结构实验报告-图的遍历","text":"数据结构实验报告-图的遍历[toc] 一、实验目的 掌握图的不同存储方式 能针对不同的存储方式实现dfs和bfs遍历 二、实验内容 用邻接矩阵存储图,输出深度优先遍历的顶点序列 用邻接表存储图,输出深度优先遍历的顶点序列 用邻接矩阵存储图,输出广度优先遍历的顶点序列 用邻接表存储图,输出广度优先遍历的顶点序列 测试数据 三、实验环境 操作系统：Ubuntu 18.04 LTS IDE：CLion 编译器：g++ 四、数据结构1.邻接矩阵，dfs 1234//a为图的邻接矩阵，flag记录是否所有的顶点都被访问，m，n分别为顶点数和边数int a[100][100]; //行列角标统一从1开始bool flag[100];int m, n; 2.邻接表，dfs 12345678910111213141516// node存储连接的顶点标号和权值struct node { int label; int weight; node(int l, int w) { label = l; weight = w; }};//标记顶点是否被访问过vector&lt;bool&gt; flag;//向量二位数组每一行为一个向量，往后存nodevector&lt;vector&lt;node&gt;&gt; graph;int m, n;int length = 0; 3.邻接矩阵，bfs 12345//a为图的邻接矩阵，flag记录是否所有的顶点都被访问，m，n分别为顶点数和边数int a[100][100]; //行列角标统一从1开始bool flag[100];int m, n;queue&lt;int&gt; q; //利用队列广度优先搜索 4.邻接表，bfs 1234567891011121314151617// node存储连接的顶点标号和权值struct node { int label; int weight; node(int l, int w) { label = l; weight = w; }};//标记顶点是否被访问过vector&lt;bool&gt; flag;//向量二位数组每一行为一个向量，往后存nodevector&lt;vector&lt;node&gt;&gt; graph;int m, n;int length = 0;queue&lt;int&gt; q; //利用队列广度优先搜索 五、算法及代码 邻接矩阵，dfs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;//a为图的邻接矩阵，flag记录是否所有的顶点都被访问，m，n分别为顶点数和边数int a[100][100]; //行列角标统一从1开始bool flag[100];int m, n;//在i这个顶点从第j个顶点开始找有没有连接其它顶点的路int findway(int i, int j) { for (int k = j; k &lt;= n; ++k) { if (a[i][k]) return k; }//找到了则返回顶点的b标号，没找到返回0 return 0;}//深度优先搜索void dfs(int i) { //访问到了这个顶点就标记被访问到，并打印输出 flag[i]=true; printf(\"%d \", i); //把i该列清0，避免重复访问 for (int l = 1; l &lt;= m; l++) { a[l][i] = 0; } //搜索下一个顶点 int j = 0; while (j = findway(i, j + 1)) { dfs(j); }}int main() { cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= m; ++j) { cin &gt;&gt; a[i][j]; } } //访问没被访问过的顶点，确保所有顶点都被访问到 for(int i = 1;i&lt;=m;i++){ if(!flag[i])dfs(i); } printf(\"\\n\"); return 0;} 2.邻接表，dfs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;// node存储连接的顶点标号和权值struct node { int label; int weight; node(int l, int w) { label = l; weight = w; }};//标记顶点是否被访问过vector&lt;bool&gt; flag;//向量二位数组每一行为一个向量，往后存nodevector&lt;vector&lt;node&gt;&gt; graph;int m, n;int length = 0;//深度优先遍历void dfs(int i){ //访问的顶点做上标记，打印顶点标号 flag[i]=true; printf(\"%d \", i); for (int j = 0; j &lt; graph[i].size(); ++j) { // 遍历graph[i]，如果没有被访问过则进入这个顶点 node nd = graph[i][j]; if(!flag[nd.label]){ length += nd.weight; dfs(nd.label); } }}int main() { cin &gt;&gt; m &gt;&gt; n; // 初始化，二位向量初始化为n行，flag标为false for (int i = 0; i &lt; m; i++) { graph.push_back(vector&lt;node&gt;()); flag.push_back(false); } //创建邻接表 for (int i = 0; i &lt; n; ++i) { int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; // 无向图，要连两次 graph[x].push_back(node(y, z)); graph[y].push_back(node(x, z)); } //dfs for (int i = 0; i &lt; m; ++i) { if(!flag[i]) dfs(i); } // 输出dfs路径长度（权值和） printf(\"\\n%d\\n\",length); return 0;} 3.邻接矩阵，bfs 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;//a为图的邻接矩阵，flag记录是否所有的顶点都被访问，m，n分别为顶点数和边数int a[100][100]; //行列角标统一从1开始bool flag[100];int m, n;queue&lt;int&gt; q; //利用队列广度优先搜索void bfs(int i) { q.push(i); printf(\"%d \", i); while (q.size()) { //队列弹出顶点 int j = q.front(); flag[j] = true; q.pop(); //访问所有未被访问的与弹出顶点相连的顶点 for (int k = 1; k &lt;= m; ++k) { if (a[j][k] &amp;&amp; !flag[k]) { //将访问过的顶点存入队列中 q.push(k); printf(\"%d \", k); } } }}int main() { cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= m; ++j) { cin &gt;&gt; a[i][j]; } } for (int i = 1; i &lt;= m; ++i) { if (!flag[i]) bfs(i); } return 0;} 4.邻接表，bfs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;// node存储连接的顶点标号和权值struct node { int label; int weight; node(int l, int w) { label = l; weight = w; }};//标记顶点是否被访问过vector&lt;bool&gt; flag;//向量二位数组每一行为一个向量，往后存nodevector&lt;vector&lt;node&gt;&gt; graph;int m, n;int length = 0;queue&lt;int&gt; q; //利用队列广度优先搜索void bfs(int i) { //队列弹出顶点 q.push(i); printf(\"%d \", i); flag[i]=true; //访问所有未被访问的与弹出顶点相连的顶点 while (q.size()) { int j = q.front(); q.pop(); for (int k = 0; k &lt; graph[j].size(); ++k) { node nd = graph[j][k]; if (!flag[nd.label]) { q.push(nd.label); //将访问过的顶点存入队列中 flag[nd.label] = true; printf(\"%d \", nd.label); length += nd.weight; } } }}int main(){ cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) { graph.push_back(vector&lt;node&gt;()); flag.push_back(false); } for (int i = 0; i &lt; n; ++i) { int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; graph[x].push_back(node(y, z)); graph[y].push_back(node(x, z)); } for (int i = 0; i &lt; m; ++i) { if (!flag[i]){ bfs(i); flag[i]= true; } } printf(\"\\n%d\\n\",length); return 0;} 六、运行结果1.邻接矩阵，dfs 2.邻接表，dfs 3.邻接矩阵，bfs 4.邻接表，bfs 七、实验问题总体上没出现大的问题，写第四个问题是把遍历向量的变量和顶点标号搞混了出现了bug，通过调试很容易解决了 八、实验小结在这次的图的遍历实验中，我学会了使用邻接矩阵和邻接表两种不同的方式存储图。我还学会了使用dfs和bfs两种方式针对不同的存储结构对图进行遍历。","path":"2019/12/29/2019-12-29/数据结构实验报告-图的遍历/","date":"12-29","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"算法","slug":"算法","permalink":"https://fnsflm.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://fnsflm.xyz/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"数据结构实验报告-排序","text":"数据结构实验报告-排序[toc] 一、实验目的 学习各种排序的基本原理，并能计算各种排序的时间复杂度 能使用c/c++实现快速排序,并记录运行时间 二、实验环境 操作系统：Ubuntu 18.04 LTS IDE：CLion 编译器：g++ 数据（随机生成）：https://paste.ubuntu.com/p/DbxZ3GFFK8/ 三、实验内容 用随机函数产生 10000（或更多）个整数（或浮点数），保存在文件（intfile.dat / realfile.dat）中 然后将文件中的所有整数（或浮点数）读入一个数组 a。用快速排序算法对上述数组 A中的数据进行排序 输出排序过程中元素的比较次数、交换（移动）次数，以及排序过程所消耗的时间（以 s 或 ms 为单位） 四、实验问题 while循环内交换顺序错误，应该先右–，然后将右边的元素放到左边。对利用key多出来的空位的做法还是不太熟悉。 while判断时写了等号，导致死循环。 五、数据结构数组，存放整型待排数据。 六、算法及代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;//a数组存储数据，size记录数据个数int a[10007];int size;int compTimes = 0;int swapTimes = 0;//随机生成数据void createdata() { string path = \"random.txt\"; ofstream f(path); srand((unsigned) time(0)); for (int i = 0; i &lt; 10000; ++i) { f &lt;&lt; rand() &lt;&lt; endl; }}//从文件中读入数据void readdata(string path) { ifstream f(path); for (size = 0; !f.eof(); size++) { f &gt;&gt; a[size]; } //尾行总是多读入一个0，所以长度减一 size--;}//快速排序void quicksort(int left, int right) { //当要排的元素只有一个时，不用操作，直接退出 if (left &gt;= right) return; int l = left, r = right; //最左端的元素为基准元素 int key = a[left]; //左边元素都小于基准元素，右边的都大于基准元素，才结束循环 while (l &lt; r) { //右指针移到比基准元素小的元素，用被移动过，没有用的空位的左指针记录 while (l &lt; r &amp;&amp; a[r] &gt;= key) r--, compTimes++; a[l] = a[r], swapTimes++; //同理，左指针移到比基准元素大的元素，用被移动过，没有用的空位的右指针记录 while (l &lt; r &amp;&amp; a[l] &lt;= key) l++, compTimes++; a[r] = a[l], swapTimes++; } //最后左右指针位置重合，且左指针的位置实际上是空的，存入基准元素 a[l] = key; //基准元素左右两边分别快排 quicksort(left, l - 1); quicksort(r + 1, right);}// 打印当前所有数据void print() { cout &lt;&lt; a[0]; for (int i = 1; i &lt; size; i++) { cout &lt;&lt; \" \" &lt;&lt; a[i]; } cout &lt;&lt; endl;}int main() { clock_t start, end; //createdata(); string path = \"/home/hjy/CLionProjects/数据结构实验-排序/random.txt\"; readdata(path); print(); //记录排序前的时间 start = clock(); quicksort(0, size - 1); //记录排序之后的时间 end = clock(); print(); cout &lt;&lt; \"比较次数： \" &lt;&lt; compTimes &lt;&lt; endl; cout &lt;&lt; \"移动次数： \" &lt;&lt; swapTimes &lt;&lt; endl; cout &lt;&lt; \"用时：\" &lt;&lt;(double)( end - start )/CLOCKS_PER_SEC&lt;&lt; \" s\" &lt;&lt; endl; return 0;} 七、运行结果 八、实验小结在这次实验中，我学会了快速排序算法的原理，能使用c++代码实现，并能统计比较次数，交换次数，以及计算时间复杂度。而且，我还学会了用ctime中的clock记录程序运行的时间。收获颇丰。","path":"2019/12/15/2019-12-15/数据结构实验报告-排序/","date":"12-15","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"算法","slug":"算法","permalink":"https://fnsflm.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://fnsflm.xyz/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"数据结构试验报告-查找","text":"数据结构试验报告-查找[toc] 一、试验目的 掌握顺序表的查找方法，折半查找方法 了解哈希表的基本概念 能用线性探测法和拉链法解决哈希冲突 二、试验环境 操作系统：Ubuntu 18.04 LTS IDE：CLion 测试数据：随机生成 三、试验内容1.问题一顺序查找是一种简单通用的查找方法。与顺序查找方法相比,折半查找的效率较高,但是它要求查找表采用顺序存储结构且元素排列有序。 建立一个整数数据文件 datafile; 从文件 datafile 读取数据,并导入一维数组中; 用顺序查找方法查找指定元素(由键盘输入),并显示查找结果; 先对数组中的元素进行排序,分别用递归和非递归两种方式实现折半查找方法。 2.问题三针对记录集合设计一个哈希表,完成相应的建表和查表程序。 假定每个记录有下列数据项:电话号码(长度不超过 11 的数字串)、用户名(长度不超过20个字符的字符串）、地址(长度不超 50个字符的字符串) 从数据文件 data.txt(预先建立)中读入各项记录,并逐一插入到哈希表中,分别用以电话号码和姓名为关键码设计相应的哈希函数; 以姓名为关键字时,采用链地址法解决冲突构造哈希表;以电话号码为关键字时,采用线性探查法解决冲突构造哈希表; 待查找的记录从键盘输入,应显示查找结果。 四、实验遇到的问题 写二分查找时，更新left、mid、right是不知道是否要多加或多减1，判断循环或者递归结束是不知道（left&gt;right）是否应该去等，使得最后的程序运行出现死循环。解决：记住一个模板，mid判断，left-1，right+1，left &gt;= right结束。 使用线性探测法解决哈希冲突时，判断取余后的位置j是否存入元素，如果存入则j++往后找，可是我没有考虑到数组越界的问题，导致程序出错，最后改为 j = (j + 1) % prime 解决。 五、数据结构 问题一数组，无特殊的数据结构 问题三 1234567891011121314151617181920//结构体存电话tele，名字name，地址address，以及考虑到拉链法要用到的指向下一个元素指针nextstruct person { long long tele; string name; string address; person *next = NULL; person(long long t, string n, string a) { tele = t; name = n; address = a; } person() {}};//persons依次存下所有的人vector&lt;person&gt; persons;//线性探测法解决哈希冲突的哈希表（电话号为索引）vector&lt;person&gt; teleIndex(prime, person(-1, \"false\", \"false\"));//初始化时打上标记//拉链法解决哈希冲突的哈希表（名字首字母为索引）vector&lt;person&gt; nameIndex(26, person()); 六、算法及代码1.问题三用python随机生成数据 1234567891011import randomf=open('data.txt','w+')for i in range(50): # 不超过11位的整数串 tele = random.randint(1,99999999999) # 26个字母随机选出随机的不超过二十个数 name = \"\".join([random.choice('zyxwvutsrqponmlkjihgfedcba') for _ in range(random.randint(1,20))]) # 26个字母及10个数字中选出不超过随机的不超过五十个数 adress = \"\".join([random.choice('zyxwvutsrqponmlkjihgfedcba1234567890') for _ in range(random.randint(1,50))]) f.write(\"{} {} {}\\n\".format(tele,name,adress))f.close() 2.问题一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;using namespace std;int a[101];int key;//随机生成100 个整数void create() { srand((unsigned) time(0)); ofstream f(\"radomdata.txt\"); for (int i = 0; i &lt; 100; i++) f &lt;&lt; rand() &lt;&lt; endl;}//从文件中读入整数void read() { ifstream f(\"radomdata.txt\"); for (int i = 0; !f.eof(); i++) { f &gt;&gt; a[i]; } f.close();}//顺序查找，依次比较，返回查找到的位置，没有查到则返回-1int SequenSearch(int test) { for (int i = 0; i &lt; 100; i++) { if (a[i] == test) return i; } return -1;}//递归的二分查找int recurBinary(int left, int right) { //查到left等于right时，查找完毕，还没找的返回-1 if (left &gt;= right) return -1; int mid = (left + right) / 2; //mid查到直接返回，没有查到分左右两部分递归 if (a[mid] == key) return mid; else if (a[mid] &gt; key) return recurBinary(left, mid - 1); else return recurBinary(mid + 1, right);}//非递归的二分查找int unrecurBinary() { int left = 0, right = 99; int mid; while (left &lt;= right) { mid = (left + right) / 2; if (a[mid] == key) return mid; if (a[mid] &lt; key) left = mid + 1; else right = mid - 1; } return -1;}int main() { //create(); read(); cin &gt;&gt; key; cout &lt;&lt; \"顺序查找\" &lt;&lt; endl; cout &lt;&lt; SequenSearch(key) &lt;&lt; endl; cout &lt;&lt; \"折半查找\" &lt;&lt; endl; sort(a, a + 100); //stl排序 cout &lt;&lt; \"递归：\" &lt;&lt; endl; cout &lt;&lt; recurBinary(0, 99) &lt;&lt; endl; cout &lt;&lt; \"非递归：\" &lt;&lt; endl; cout &lt;&lt; unrecurBinary() &lt;&lt; endl; return 0;} 3.问题三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;fstream&gt;#include&lt;vector&gt;#define prime 83using namespace std;//结构体存电话tele，名字name，地址address，以及考虑到拉链法要用到的指向下一个元素指针nextstruct person { long long tele; string name; string address; person *next = NULL; person(long long t, string n, string a) { tele = t; name = n; address = a; } person() {}};//persons依次存下所有的人vector&lt;person&gt; persons;//线性探测法解决哈希冲突的哈希表（电话号为索引）vector&lt;person&gt; teleIndex(prime, person(-1, \"false\", \"false\"));//初始化时打上标记//拉链法解决哈希冲突的哈希表（名字首字母为索引）vector&lt;person&gt; nameIndex(26, person());// 从文件中读入数据存入persons向量中void create() { ifstream f(\"/home/hjy/CLionProjects/数据结构查找/data.txt\"); for (/*int i = 0*/; !f.eof();/* i++*/) { long long t; string n, a; f &gt;&gt; t &gt;&gt; n &gt;&gt; a; persons.push_back(person(t, n, a)); dataNumber++; //cout &lt;&lt; dataNumber &lt;&lt; endl; //cout &lt;&lt; persons[i].tele &lt;&lt; persons[i].name &lt;&lt; persons[i].address &lt;&lt; endl; } f.close();}//拉链法void createNameIndex() { for (int i = 0; i &lt; dataNumber; i++) { //以name的首字母索引 int j = persons[i].name[0] - 'a'; person *pt = nameIndex[j].next; //判断是否有元素，没有元素直接赋next地址，有元素则while循环找下去 if (pt == NULL) nameIndex[j].next = &amp;persons[i]; else { while (pt-&gt;next != NULL) pt = pt-&gt;next; pt-&gt;next = &amp;persons[i]; } } // 输出哈希表 cout &lt;&lt; \"拉链法:\" &lt;&lt; endl; for (int i = 0; i &lt; 26; i++) { cout &lt;&lt; (char) (i + 'a'); person *p = nameIndex[i].next; while (p != NULL) { cout &lt;&lt; \" --&gt; { tele: \" &lt;&lt; p-&gt;tele &lt;&lt; \", \" &lt;&lt; \"name: \" &lt;&lt; p-&gt;name &lt;&lt; \", \" &lt;&lt; \"adress: \" &lt;&lt; p-&gt;address &lt;&lt; \"}\"; p = p-&gt;next; } cout &lt;&lt; endl; }}//拉链法查找元素person *searchNameIndex(long long tele, string name, string address) { //以name的首字母为索引，然后while循环查找链表 int i = name[0] - 'a'; person *p = nameIndex[i].next; while (p != NULL) { if (p-&gt;name == name &amp;&amp; p-&gt;tele == tele &amp;&amp; p-&gt;address == address) return p; p = p-&gt;next; } return NULL;}//线性探查法void createTeleIndex() { for (int i = 0; i &lt; dataNumber; i++) { int j = (int)(persons[i].tele % prime); // 如果j位置已经存入了元素，就依次向下查找下去，考虑到位置j可能越界，利用取余运算来线性探查 while(teleIndex[j].tele!=-1) j = (j + 1)%prime; teleIndex[j].tele = persons[i].tele; teleIndex[j].name = persons[i].name; teleIndex[j].address = persons[i].address; } // 输出哈希表 cout &lt;&lt; \"\\n线性探测法： \" &lt;&lt; endl; for(int i = 0; i &lt; prime; i++){ cout &lt;&lt; i &lt;&lt; \": \"; if(teleIndex[i].tele!=-1) cout &lt;&lt; \"{tele: \" &lt;&lt; teleIndex[i].tele &lt;&lt; \", \" &lt;&lt; \"name: \" &lt;&lt; teleIndex[i].name &lt;&lt; \", \" &lt;&lt; \"adress: \" &lt;&lt; teleIndex[i].address &lt;&lt; \"}\"; cout &lt;&lt; endl; }}//线性探测法查找元素person *searchTeleIndex(long long tele, string name, string address) { int i = (int)(tele % prime); while(teleIndex[i].tele!=tele){ i = (i + 1)%prime; if(teleIndex[i].tele == -1)return NULL; } return &amp;teleIndex[i];}int main() { create(); createNameIndex(); cout &lt;&lt; \"\\nsearch: 51690796582 dxzfdkwjh rzq1zrt4kqltruyt023v6tih6y\" &lt;&lt; endl; person *p = searchNameIndex(51690796582, \"dxzfdkwjh\", \"rzq1zrt4kqltruyt023v6tih6y\"); cout &lt;&lt; p &lt;&lt; endl; createTeleIndex(); cout &lt;&lt; \"\\nsearch: 88018773818 zfavvdvekqcncyhduh mnvkmmow7bz03w9gidjngjy7p0d1u6i9vsc4lkky\" &lt;&lt; endl; person *q = searchNameIndex(88018773818, \"zfavvdvekqcncyhduh\", \"mnvkmmow7bz03w9gidjngjy7p0d1u6i9vsc4lkky\"); cout &lt;&lt; q &lt;&lt; endl; return 0;} 七、运行结果 问题一 1234567832181顺序查找9折半查找递归：99非递归：99 问题三数据 第2-27行为拉链法存储的哈希表结果，第33-115行为线性探测法的存储结果，第30,118为举的两个测试样例，返回的地址值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119拉链法:a --&gt; { tele: 74235964265, name: ayidhvaecxkhajppyax, adress: tborsuofh2d7nwj7ksgvkxxe0e}b --&gt; { tele: 68799950797, name: bazwtfkvh, adress: ii6groruv8727cdphfzg0amk} --&gt; { tele: 49625049710, name: bhoqelxrhwvolrknxbz, adress: vq36jv}cd --&gt; { tele: 29141058628, name: dpuwoogxpl, adress: 7llwwqkbnuiysl0v15g86jj7cf93} --&gt; { tele: 51690796582, name: dxzfdkwjh, adress: rzq1zrt4kqltruyt023v6tih6y} --&gt; { tele: 1910185626, name: doawstrhzrrjn, adress: rh74yfn0ookag13y98rue8o0koejrt4uxt6h}e --&gt; { tele: 71490078112, name: evzujfl, adress: b8dl29zlwikbe7vy50ikhqcefehylhz5l841p} --&gt; { tele: 14946648036, name: enfintphapisoveqzi, adress: jq23fbv7hsiy28xvxo4r} --&gt; { tele: 56636907856, name: eownwnjolepgaka, adress: 57wamfzboy2wdhch05hs37zljufqvs}f --&gt; { tele: 21227056353, name: fndomawrm, adress: 5tpbx98fgzg6ekljs1ddp3ojz9}g --&gt; { tele: 14080181523, name: givb, adress: x8n0dbl98t520kqa} --&gt; { tele: 86993960393, name: grtrr, adress: lgfm3sdt2s}h --&gt; { tele: 28774393375, name: hcnxkoeqcgldk, adress: b3x27l1krrxbvswm8uclxa0n8zcaz2492egy12de8hm} --&gt; { tele: 52429222594, name: hlswfacs, adress: v885w5bjz9vq2v5bh0r8mtec4jpt5vdapdj2kmthsjffbc7} --&gt; { tele: 86654497485, name: h, adress: yhqyr0} --&gt; { tele: 18590523681, name: hvdddansrrr, adress: xysyqlknjuesx2o66vb8utt100mqdz20w9majx} --&gt; { tele: 40944802458, name: hkabprxgnytomiasj, adress: 6xvjp7xlomny46coirk4w4nn4g4blfjsqx4r7fs0fodh}ij --&gt; { tele: 50023186053, name: jsoaepssdbt, adress: hfmpmvyu}k --&gt; { tele: 44587355328, name: ksiwtrwgqqvdisf, adress: q97r4uf94xs9gudp0se6mwh5pqxf3fm7540uuqcy6j}l --&gt; { tele: 26942443021, name: lfwodrhpsrcyyxexw, adress: tdh7ipv0v0i6l29stboes2wue2qajjmgv6st924rtvw6oi}m --&gt; { tele: 7311505320, name: mveyupbvezmyqv, adress: nqdecdjwhcu} --&gt; { tele: 46124498206, name: mw, adress: 2u7qz2xsqypgupt3sr5c} --&gt; { tele: 86581866669, name: mlekcdmuvrlicw, adress: 6wnzgibx53tkyytgxgr267mvegmjsolp7ij5obs2ns} --&gt; { tele: 90416558407, name: mrzr, adress: cigpggo2hgvk08tit8}n --&gt; { tele: 22106201384, name: nnsvovfeykmfnsksngs, adress: bfb34n46akj2vjeco0tm3fvtfcs2gurt4yda}o --&gt; { tele: 46277162140, name: omldrzp, adress: ywa7zs9y618yy4fyhl5jiy8jn840fy0h2gi6xjjemkmu}p --&gt; { tele: 48802626243, name: pdrmxjkuv, adress: 4on86cbk4gawne02m1fs0321cmczdqs2wq} --&gt; { tele: 16435613863, name: plnhllgakuplufa, adress: r6wcxb392kflvl1j0yk3c5q6ur2kai8ravljc958wkr}q --&gt; { tele: 70553315085, name: qlntd, adress: 6lfbj8ypckkhtbrg9makzsd2of}r --&gt; { tele: 27710898402, name: rggooibhxaukgoxbjsc, adress: 9gl28i6zjs4u7cfivqvccarqj8k3iudsae4zjo18} --&gt; { tele: 96825588138, name: rlqucexme, adress: hgumdwsu90hgyndr6lm62rcs57n8yv8rucqa8teonkjb} --&gt; { tele: 91215068600, name: rw, adress: o2wu9zw6tkqo7ojxwmayix0doy} --&gt; { tele: 37492557238, name: rnbbtuegv, adress: huowyqd8qqf}s --&gt; { tele: 67334160807, name: szdcvgemf, adress: o8ewyx1hu45wj9} --&gt; { tele: 17972842647, name: shgxuteqndqzc, adress: 3xvuqvdj7bmttxh} --&gt; { tele: 90022364471, name: scnesffvbbgdtpq, adress: 359m0d4rz79fyvbixmcblv1dszw6bdaetod5bj8}t --&gt; { tele: 37379611121, name: t, adress: bhotof4mf630c8ebprh8quvs89xjwaq96}u --&gt; { tele: 30434058000, name: ucqwdsavv, adress: li1463p3keazzd} --&gt; { tele: 56623968519, name: upagfnifi, adress: 06y}v --&gt; { tele: 86456184736, name: vqcedszplsblfdsjcjg, adress: fvzohxe18iw73mlufumg8esd1q2v} --&gt; { tele: 18478208176, name: vaagnjmtgookvprd, adress: 2po1g4fyr1hq23a1x80mbpqojvd3j3dllmnpozfgnhkwwix} --&gt; { tele: 84279659588, name: vi, adress: 417y2dfm4067snyk60ebsds1ob3r3w}w --&gt; { tele: 16502167130, name: w, adress: tq87psb4ajr6ops4i7rhsr75x8ryada5mes}x --&gt; { tele: 34081397751, name: xzylvpdlju, adress: q5ara21mbu} --&gt; { tele: 84469092641, name: xqoxgz, adress: tw64itbzx8uione4pzi19i7hts2f79r4fd68brxdrza2r3tw} --&gt; { tele: 82180150934, name: xsmz, adress: 1}yz --&gt; { tele: 24249042325, name: z, adress: xtenp3zsz70cg4es3iif9k} --&gt; { tele: 85292247897, name: zhobfxccifobzjpd, adress: gwteevzce7fdhu34ln9thgryhdzhfxvx3} --&gt; { tele: 49458609694, name: zubrnvn, adress: 3d30wqvqak} --&gt; { tele: 88018773818, name: zfavvdvekqcncyhduh, adress: mnvkmmow7bz03w9gidjngjy7p0d1u6i9vsc4lkky}search: 51690796582 dxzfdkwjh rzq1zrt4kqltruyt023v6tih6y0x55dcfdd4add0线性探测法： 0: {tele: 40944802458, name: , adress: }1: {tele: 74235964265, name: ayidhvaecxkhajppyax, adress: tborsuofh2d7nwj7ksgvkxxe0e}2: {tele: 34081397751, name: xzylvpdlju, adress: q5ara21mbu}3: {tele: 18590523681, name: hvdddansrrr, adress: xysyqlknjuesx2o66vb8utt100mqdz20w9majx}4: 5: {tele: 96825588138, name: rlqucexme, adress: hgumdwsu90hgyndr6lm62rcs57n8yv8rucqa8teonkjb}6: 7: {tele: 37492557238, name: rnbbtuegv, adress: huowyqd8qqf}8: 9: {tele: 86581866669, name: mlekcdmuvrlicw, adress: 6wnzgibx53tkyytgxgr267mvegmjsolp7ij5obs2ns}10: {tele: 91215068600, name: rw, adress: o2wu9zw6tkqo7ojxwmayix0doy}11: {tele: 16435613863, name: plnhllgakuplufa, adress: r6wcxb392kflvl1j0yk3c5q6ur2kai8ravljc958wkr}12: {tele: 44587355328, name: ksiwtrwgqqvdisf, adress: q97r4uf94xs9gudp0se6mwh5pqxf3fm7540uuqcy6j}13: 14: {tele: 18478208176, name: vaagnjmtgookvprd, adress: 2po1g4fyr1hq23a1x80mbpqojvd3j3dllmnpozfgnhkwwix}15: {tele: 86654497485, name: h, adress: yhqyr0}16: {tele: 49625049710, name: bhoqelxrhwvolrknxbz, adress: vq36jv}17: {tele: 56623968519, name: upagfnifi, adress: 06y}18: 19: 20: {tele: 14080181523, name: givb, adress: x8n0dbl98t520kqa}21: {tele: 28774393375, name: hcnxkoeqcgldk, adress: b3x27l1krrxbvswm8uclxa0n8zcaz2492egy12de8hm}22: {tele: 26942443021, name: lfwodrhpsrcyyxexw, adress: tdh7ipv0v0i6l29stboes2wue2qajjmgv6st924rtvw6oi}23: 24: 25: 26: {tele: 71490078112, name: evzujfl, adress: b8dl29zlwikbe7vy50ikhqcefehylhz5l841p}27: 28: {tele: 84469092641, name: xqoxgz, adress: tw64itbzx8uione4pzi19i7hts2f79r4fd68brxdrza2r3tw}29: 30: {tele: 46277162140, name: omldrzp, adress: ywa7zs9y618yy4fyhl5jiy8jn840fy0h2gi6xjjemkmu}31: 32: {tele: 90416558407, name: mrzr, adress: cigpggo2hgvk08tit8}33: {tele: 84279659588, name: vi, adress: 417y2dfm4067snyk60ebsds1ob3r3w}34: {tele: 82180150934, name: xsmz, adress: 1}35: 36: {tele: 88018773818, name: zfavvdvekqcncyhduh, adress: mnvkmmow7bz03w9gidjngjy7p0d1u6i9vsc4lkky}37: {tele: 24249042325, name: z, adress: xtenp3zsz70cg4es3iif9k}38: 39: 40: {tele: 67334160807, name: szdcvgemf, adress: o8ewyx1hu45wj9}41: {tele: 37379611121, name: t, adress: bhotof4mf630c8ebprh8quvs89xjwaq96}42: 43: 44: 45: {tele: 7311505320, name: mveyupbvezmyqv, adress: nqdecdjwhcu}46: {tele: 85292247897, name: zhobfxccifobzjpd, adress: gwteevzce7fdhu34ln9thgryhdzhfxvx3}47: 48: 49: {tele: 30434058000, name: ucqwdsavv, adress: li1463p3keazzd}50: {tele: 50023186053, name: jsoaepssdbt, adress: hfmpmvyu}51: 52: 53: 54: {tele: 1910185626, name: doawstrhzrrjn, adress: rh74yfn0ookag13y98rue8o0koejrt4uxt6h}55: {tele: 52429222594, name: hlswfacs, adress: v885w5bjz9vq2v5bh0r8mtec4jpt5vdapdj2kmthsjffbc7}56: 57: 58: 59: {tele: 48802626243, name: pdrmxjkuv, adress: 4on86cbk4gawne02m1fs0321cmczdqs2wq}60: {tele: 51690796582, name: dxzfdkwjh, adress: rzq1zrt4kqltruyt023v6tih6y}61: {tele: 16502167130, name: w, adress: tq87psb4ajr6ops4i7rhsr75x8ryada5mes}62: {tele: 22106201384, name: nnsvovfeykmfnsksngs, adress: bfb34n46akj2vjeco0tm3fvtfcs2gurt4yda}63: {tele: 86993960393, name: grtrr, adress: lgfm3sdt2s}64: 65: {tele: 70553315085, name: qlntd, adress: 6lfbj8ypckkhtbrg9makzsd2of}66: {tele: 49458609694, name: zubrnvn, adress: 3d30wqvqak}67: {tele: 27710898402, name: rggooibhxaukgoxbjsc, adress: 9gl28i6zjs4u7cfivqvccarqj8k3iudsae4zjo18}68: {tele: 14946648036, name: enfintphapisoveqzi, adress: jq23fbv7hsiy28xvxo4r}69: {tele: 56636907856, name: eownwnjolepgaka, adress: 57wamfzboy2wdhch05hs37zljufqvs}70: {tele: 68799950797, name: bazwtfkvh, adress: ii6groruv8727cdphfzg0amk}71: {tele: 46124498206, name: mw, adress: 2u7qz2xsqypgupt3sr5c}72: {tele: 17972842647, name: shgxuteqndqzc, adress: 3xvuqvdj7bmttxh}73: {tele: 90022364471, name: scnesffvbbgdtpq, adress: 359m0d4rz79fyvbixmcblv1dszw6bdaetod5bj8}74: 75: {tele: 29141058628, name: dpuwoogxpl, adress: 7llwwqkbnuiysl0v15g86jj7cf93}76: {tele: 21227056353, name: fndomawrm, adress: 5tpbx98fgzg6ekljs1ddp3ojz9}77: 78: 79: {tele: 86456184736, name: vqcedszplsblfdsjcjg, adress: fvzohxe18iw73mlufumg8esd1q2v}80: 81: 82: {tele: 40944802458, name: hkabprxgnytomiasj, adress: 6xvjp7xlomny46coirk4w4nn4g4blfjsqx4r7fs0fodh}search: 88018773818 zfavvdvekqcncyhduh mnvkmmow7bz03w9gidjngjy7p0d1u6i9vsc4lkky0x55dcfdd4b460 八、实验小结通过这次试验我掌握了二分查找算法的原理，并能通过算法实现，并且我记住了一种更新left、right方式，以便下次写二分算法时能准确快速的写出程序。我学习到了哈希算法的基本原理以及解决哈希冲突的方法，并能用代码实现拉链法和线性探查法。 九、附录：生成的随机数 问题一 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001015628199512880410222268512517811046129561288932181217815903234291764479073951206730970841317262199062217827172874112847278382902326370230891031769622822926486914152021791319662200831057221209234472204731088901017784122751146412522261951116727225121727252124203047178959487265724493185431098526927241313042136562177237210344501249631715204812440319278170832016998072984929526168308282271312148571792522024719102941058413762353415742147391272822539319921483225983190363080524366 问题三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495014080181523 givb x8n0dbl98t520kqa70553315085 qlntd 6lfbj8ypckkhtbrg9makzsd2of74235964265 ayidhvaecxkhajppyax tborsuofh2d7nwj7ksgvkxxe0e48802626243 pdrmxjkuv 4on86cbk4gawne02m1fs0321cmczdqs2wq28774393375 hcnxkoeqcgldk b3x27l1krrxbvswm8uclxa0n8zcaz2492egy12de8hm30434058000 ucqwdsavv li1463p3keazzd27710898402 rggooibhxaukgoxbjsc 9gl28i6zjs4u7cfivqvccarqj8k3iudsae4zjo1867334160807 szdcvgemf o8ewyx1hu45wj929141058628 dpuwoogxpl 7llwwqkbnuiysl0v15g86jj7cf9351690796582 dxzfdkwjh rzq1zrt4kqltruyt023v6tih6y34081397751 xzylvpdlju q5ara21mbu16435613863 plnhllgakuplufa r6wcxb392kflvl1j0yk3c5q6ur2kai8ravljc958wkr7311505320 mveyupbvezmyqv nqdecdjwhcu24249042325 z xtenp3zsz70cg4es3iif9k46124498206 mw 2u7qz2xsqypgupt3sr5c1910185626 doawstrhzrrjn rh74yfn0ookag13y98rue8o0koejrt4uxt6h96825588138 rlqucexme hgumdwsu90hgyndr6lm62rcs57n8yv8rucqa8teonkjb26942443021 lfwodrhpsrcyyxexw tdh7ipv0v0i6l29stboes2wue2qajjmgv6st924rtvw6oi68799950797 bazwtfkvh ii6groruv8727cdphfzg0amk21227056353 fndomawrm 5tpbx98fgzg6ekljs1ddp3ojz917972842647 shgxuteqndqzc 3xvuqvdj7bmttxh85292247897 zhobfxccifobzjpd gwteevzce7fdhu34ln9thgryhdzhfxvx352429222594 hlswfacs v885w5bjz9vq2v5bh0r8mtec4jpt5vdapdj2kmthsjffbc786456184736 vqcedszplsblfdsjcjg fvzohxe18iw73mlufumg8esd1q2v86654497485 h yhqyr084469092641 xqoxgz tw64itbzx8uione4pzi19i7hts2f79r4fd68brxdrza2r3tw86581866669 mlekcdmuvrlicw 6wnzgibx53tkyytgxgr267mvegmjsolp7ij5obs2ns49625049710 bhoqelxrhwvolrknxbz vq36jv90022364471 scnesffvbbgdtpq 359m0d4rz79fyvbixmcblv1dszw6bdaetod5bj849458609694 zubrnvn 3d30wqvqak88018773818 zfavvdvekqcncyhduh mnvkmmow7bz03w9gidjngjy7p0d1u6i9vsc4lkky90416558407 mrzr cigpggo2hgvk08tit846277162140 omldrzp ywa7zs9y618yy4fyhl5jiy8jn840fy0h2gi6xjjemkmu91215068600 rw o2wu9zw6tkqo7ojxwmayix0doy37492557238 rnbbtuegv huowyqd8qqf50023186053 jsoaepssdbt hfmpmvyu18478208176 vaagnjmtgookvprd 2po1g4fyr1hq23a1x80mbpqojvd3j3dllmnpozfgnhkwwix44587355328 ksiwtrwgqqvdisf q97r4uf94xs9gudp0se6mwh5pqxf3fm7540uuqcy6j84279659588 vi 417y2dfm4067snyk60ebsds1ob3r3w71490078112 evzujfl b8dl29zlwikbe7vy50ikhqcefehylhz5l841p18590523681 hvdddansrrr xysyqlknjuesx2o66vb8utt100mqdz20w9majx37379611121 t bhotof4mf630c8ebprh8quvs89xjwaq9616502167130 w tq87psb4ajr6ops4i7rhsr75x8ryada5mes14946648036 enfintphapisoveqzi jq23fbv7hsiy28xvxo4r82180150934 xsmz 156623968519 upagfnifi 06y56636907856 eownwnjolepgaka 57wamfzboy2wdhch05hs37zljufqvs22106201384 nnsvovfeykmfnsksngs bfb34n46akj2vjeco0tm3fvtfcs2gurt4yda86993960393 grtrr lgfm3sdt2s40944802458 hkabprxgnytomiasj 6xvjp7xlomny46coirk4w4nn4g4blfjsqx4r7fs0fodh","path":"2019/12/01/2019-12-1/数据结构试验报告-查找/","date":"12-01","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"算法","slug":"算法","permalink":"https://fnsflm.xyz/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构实验报告-树","text":"数据结构实验报告-树[toc] 一、实验目的 熟悉树的节点类型和创建树等基本操作 掌握二叉树的前中后序遍历 掌握哈夫曼树的编码和解码 二、实验环境 操作系统：Ubuntu 18.04 LTS IDE：CLion 三、实验内容1. 二叉树的遍历运算 创建二叉树的链表表示 实现二叉树的先序遍历运算,输出先序遍历序列 实现二叉树的中序遍历运算,输出中序遍历序列 实现二叉树的后序遍历运算,输出后序遍历序列 2. 哈夫曼编码译码 I:初始化(Initialization)。从终端(键盘)读入字符集的大小 n,n 个字符及 n 个权值,建立哈夫曼树并将其存于文件 hfmTree 中 E:编码(Encoding)。利用已经建好的哈夫曼树,为每个叶子结点编码,并对文本文件 ToBeTran中的正文进行编码,然后将结果存入文件 CodeFile 中 D:译码(Decoding)。利用已经建好的哈夫曼树,对文本文件 CodeFile 中的代码进行翻译,结果存入 TextFile 中 V:比较文件 ToBeTran 和 TextFile 的内容是否相同,若不同,则编译码过程中有错误 四、实验问题 在写遍历时递归前没有判断是否有左或右子树，导致错误。 对文件的输入输出仍然不熟练，尝试过c语言的fopen和c++的ifstream，但不知道为何总是打印出来的乱码。最后将相对路径改为绝对路径后成功解决问题（用的ifstream），但仍然不知道原因。 在对ToBeTran.txt文件读入时不知道如何结束输入，用while(!fin.eof())结束输入时，最后的字符总会重复一次，尝试用换行符结束输入，但不知道为何换行符没有被读入，最后自己在文件加了个句号来判断结束解决问题，仍然不知道原因。 五、数据结构1.二叉树的遍历12345678910111213//树的节点struct node { char data; int lchild = -1; int rchild = -1; node(int d) { data = d; }};//存储树vector&lt;node&gt; tree; 2.哈夫曼树12345678910111213141516171819202122232425262728293031323334//哈夫曼树的节点，分别存储了节点代表字符，该节点的位置（地址），父节点位置，左右子树位置//结构体重载了两个构造方法，一个用于最初节点的创建，一个用于合并的节点的创建//小于号运算符重载，用于两个结构体大小的比较struct node { char data = ' '; int position; int parent = -1; int lchild = -1; int rchild = -1; double p; node(char c, double x, int pt) { data = c; p = x; position = pt; } node(double x, int pt, int l, int r) { p = x; position = pt; lchild = l; rchild = r; } bool operator&lt;(const node &amp;d) const { return d.p &lt; p; }};//用vector存储树vector&lt;node&gt; tree;//利用优先队列创建哈夫曼树，其中node结点已经运算符重载，可以比较大小priority_queue&lt;node&gt; dt; 六、主要算法1.二叉树的遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//树的节点struct node { char data; int lchild = -1; int rchild = -1; node(int d) { data = d; }};//vector存储树vector&lt;node&gt; tree;//创建树，存储时利用线性存储，但节点中有lchild和rchild，所以之后使用的为树的链式存储void createTree() { tree.push_back(node(0)); int i = 1; while (true) { char ch; ch = getchar(); if (ch == '.') return; //利用node的构造方法写直接将节点添加到vector中 tree.push_back(node(ch)); if (i % 2)tree[i / 2].rchild = i; else tree[i / 2].lchild = i; i++; }}//先序遍历void rootlr(int position) { cout &lt;&lt; tree[position].data; if (tree[position].lchild != -1) rootlr(tree[position].lchild); if (tree[position].rchild != -1) rootlr(tree[position].rchild);}//中序遍历void lrootr(int posion) { if (tree[posion].lchild != -1) lrootr(tree[posion].lchild); cout &lt;&lt; tree[posion].data; if (tree[posion].rchild != -1) lrootr(tree[posion].rchild);}//后序遍历void lrroot(int position){ if (tree[position].lchild != -1) lrroot(tree[position].lchild); if (tree[position].rchild != -1) lrroot(tree[position].rchild); cout &lt;&lt; tree[position].data;}int main() { createTree(); rootlr(1); cout &lt;&lt; endl; lrootr(1); cout &lt;&lt; endl; lrroot(1); cout &lt;&lt; endl; return 0;} 2.哈夫曼树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;//哈夫曼树的节点，分别存储了节点代表字符，该节点的位置（地址），父节点位置，左右子树位置//结构体重载了两个构造方法，一个用于最初节点的创建，一个用于合并的节点的创建//小于号运算符重载，用于两个结构体大小的比较struct node { char data = ' '; int position; int parent = -1; int lchild = -1; int rchild = -1; double p; node(char c, double x, int pt) { data = c; p = x; position = pt; } node(double x, int pt, int l, int r) { p = x; position = pt; lchild = l; rchild = r; } bool operator&lt;(const node &amp;d) const { return d.p &lt; p; }};//用vector存储树vector&lt;node&gt; tree;//利用优先队列创建哈夫曼树，其中node结点已经运算符重载，可以比较大小int createTree(string path) { ifstream fin(path); char ch; double p; priority_queue&lt;node&gt; dt; int t = 0; while (!fin.eof()) { //读入初始节点，并分别压入优先队列和向量中 fin &gt;&gt; ch &gt;&gt; p; node nd = node(ch, p, t++); tree.push_back(nd); dt.push(nd); } while (dt.size() &gt; 1) { //从优先队列中弹出两个最小的节点 node a = dt.top(); dt.pop(); node b = dt.top(); dt.pop(); //记录父节点的位置，创建合并的节点压入优先队列和向量中 tree[a.position].parent = t; tree[b.position].parent = t; node nd = node(a.p + b.p, t++, a.position, b.position); dt.push(nd); tree.push_back(nd); } fin.close(); return dt.top().position;}//向文件中存入创建的哈夫曼树的信息void store(int head, string path) { ofstream fout(path); for (int i = 0; i &lt;= head; i++) { fout &lt;&lt; tree[i].data &lt;&lt; \" \" &lt;&lt; tree[i].p &lt;&lt; \" \" &lt;&lt; tree[i].parent &lt;&lt; \" \" &lt;&lt; tree[i].lchild &lt;&lt; \" \" &lt;&lt; tree[i].rchild &lt;&lt; \" \" &lt;&lt; endl; }}//题干未要求，打印每个字符对应的编码到文件中void everyencoding(int head, string path) { ofstream fout(path); for (int i = 0; i &lt; head &amp;&amp; tree[i].data != ' '; i++) { stack&lt;int&gt; st; int position = tree[i].position; int parent = tree[i].parent; while(parent != -1){ if(tree[parent].lchild == position)st.push(0); if(tree[parent].rchild == position)st.push(1); position = parent; parent = tree[parent].parent; } fout &lt;&lt; tree[i].data &lt;&lt; \" \"; while(st.size()){ fout &lt;&lt; st.top(); st.pop(); } fout &lt;&lt; endl; }}//对输入的文件编码并输出到一个新文件中void encoding(int head, string path, string path2) { ifstream fin(path); ofstream fout(path2); while (true) { char ch; fin &gt;&gt; ch; if(ch == '.')break; for (int i = 0; i &lt;= head; i++) { //解码时是从叶子节点到根，利用栈逆序 if (tree[i].data == ch) { stack&lt;int&gt; st; //用position存储当前节点位置，parent存储父节点位置 int position = tree[i].position; int parent = tree[i].parent; while (parent != -1) { if (tree[parent].lchild == position)st.push(0); if (tree[parent].rchild == position)st.push(1); position = parent; parent = tree[parent].parent; } //逆序输出 while (st.size()) { fout &lt;&lt; st.top(); //cout &lt;&lt; st.top(); st.pop(); }//cout &lt;&lt; endl; break; } } } fout &lt;&lt; endl; fin.close(); fout.close();}//对输入的编码解码，并输入到另一个文件中void decoding(int head, string path,string path2) { ifstream fin(path); ofstream fout(path2); string str; fin &gt;&gt; str; for (int i = 0, position = head; i &lt; str.length(); i++) { if (str[i] == '0')position = tree[position].lchild; else position = tree[position].rchild; if (tree[position].rchild == -1 &amp;&amp; tree[position].lchild == -1) { //cout &lt;&lt; tree[position].data; fout &lt;&lt; tree[position].data; position = head; } }}int main() { string readpath = \"/home/hjy/CLionProjects/数据结构树/text1.txt\"; string writepath = \"/home/hjy/CLionProjects/数据结构树/hfmTree.txt\"; string every = \"/home/hjy/CLionProjects/数据结构树/encode.txt\"; string txtpath = \"/home/hjy/CLionProjects/数据结构树/tobetran.txt\"; string codepath = \"/home/hjy/CLionProjects/数据结构树/CodeFile.txt\"; string textfile = \"/home/hjy/CLionProjects/数据结构树/TextFile.txt\"; int head = createTree(readpath); store(head, writepath); everyencoding(head,every); encoding(head, txtpath, codepath); decoding(head, codepath, textfile); return 0;} 七、实验小结这次实验中我收获颇多，学会了二叉树的先中后序遍历，哈夫曼树的创建、编码和解码。我还学会了vector存储树，在写哈夫曼实验中，我基本掌握了c++的文件输入输出(ifstream/ofstream)，我学会了结构体里写不同的构造方法以及运算符重载，我能熟练的使用stl中的向量、优先队列、栈等工具。","path":"2019/11/18/2019-11-18/数据结构实验报告-树/","date":"11-18","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"算法","slug":"算法","permalink":"https://fnsflm.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","permalink":"https://fnsflm.xyz/tags/%E6%A0%91/"}]},{"title":"数据结构实验报告-串","text":"数据结构实验报告-串 [toc] 一、实验目的 掌握串的建立，遍历，插入等基本操作 熟练文件读取等基本操作 熟练string库的使用 二、实验题目 文学研究人员经常需要统计某篇英文小说中某些词语出现的次数,试写一个程序完成该统计要求 英文小说存于一个文本文件中(有多行),需要统计的单词由键盘输入。程序运行结束后输出该关键字在文中出现的总次数以及出现该关键字的行号和在该行中出现的次数。 三、实验环境 操作系统：Ubuntu 18.04 LTS IDE：CLion 数据： https://paste.ubuntu.com/p/h5MG25rmkR/ 网上下载的英文小说：Venus in Furs.txt 路径：”/home/hjy/CLionProjects/数据结构实验字符串/Venus in Furs.txt” 四、实验问题 文件读取的问题不是很清楚c++如何读入文件，取出数据，终止循环等。 对于行末的处理在写split函数时不知道何时是行末并终止循环。 对string的一些常见操作不熟悉在使用string中的substr时，要输入的是子串的长度，误认为子串的尾指针（索引值），导致结果错误。 五、数据结构 c++ stl 中的 stirng str[10001] 存储一行中的每个单词 string tmp 存储从文件中读入一行的字符串 string keyword 存储要查找的关键字 六、主要算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;//str存一行所有的单词，tmp为一行的字符串string str[10001];string tmp;//将tmp以空格为间隔，分成一个个string单词存到str中int split() { int length = 0; int before = 0; int now; //开头先跳过所有的空格 while (tmp[before] == ' ')before++; for (now = before + 1; now &lt; tmp.length(); now++) { if (tmp[now] == '\\r') { str[length++] = tmp.substr(before, now - before); return length; } if (tmp[now] == ' ' || tmp[now] == '.' || tmp[now] == ',') { str[length++] = tmp.substr(before, now - before); //考虑中间有多个空格时跳过去 while (tmp[now] == ' ')now++; before = now; } } // 返回str的长度length，即一行的单词数 return length;}int main() { //读取txt文件 ifstream txt(\"/home/hjy/CLionProjects/数据结构实验字符串/Venus in Furs.txt\"); int n; int times = 0; string keyworkd;//用string类型存要查找的关键字 cout &lt;&lt; \"Enter the keyword： \"; cin &gt;&gt; keyworkd; int line = 0; //记录行号 while (!txt.eof()) { line++; //用getline函数读取一行字符串 getline(txt, tmp); int m = 0; //cout &lt;&lt; tmp &lt;&lt; endl; n = split(); for (int i = 0; i &lt; n; ++i) { if (str[i] == keyworkd)m++; } times += m; if(m!=0) cout &lt;&lt; line &lt;&lt; \": \" &lt;&lt; m &lt;&lt; endl; } txt.close(); cout &lt;&lt; \"total: \" &lt;&lt; times &lt;&lt; endl; return 0;} 七、实验小结 这次实验，将文本读入并储存至string中，遍历string，分成一个个小的字符串，也就是单词，然后再进行与关键词的比较。在实验中，我学会了用ifstream读入文本文件，并用getline依次读入每一行的字符串。我使用了string自带的length来遍历，用重载过的”==”来觉字符串，使用substr来读取子串。在实验过程中，我不知道如何判断行末，使用调试后发现，每一行都是以’\\r’回车结束，所以我也通过’\\r’来判断行末。 这次实验，我学到了许多文件读取，文件存储特点，字符串的知识，收获了许多。","path":"2019/11/03/2019-11-3/数据结构实验报告-串/","date":"11-03","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"算法 - 字符串","slug":"算法-字符串","permalink":"https://fnsflm.xyz/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"数据结构试验报告-栈和队列","text":"数据结构试验报告-栈和队列 [toc] 一、试验题目与目的 以一个 m*n 的长方阵表示迷宫，0和1分别表示迷宫中的通路和障碍。设计一个程序，对任意设定的迷宫，求出一条从入口到出口的通路，或得出没有通路的结论。 分别用栈和队列作为数据结构，使用非递归的dfs和bfs算法，找出路径。 二、试验环境 操作系统： Ubuntu 18.04 LTS IDE：CLion Online Judge：vjudge &amp; POJ 题目：https://vjudge.net/problem/POJ-3984注：这里找了一道相似的题用于测试提交，代码最终结果仍然以该实验题目为准 三、实验问题1.选择如何实现数据结构出现错误我先选择的是stl中的stack和queue来作为栈和队列，但发现最后需要输出路径时，由于stack和queue不提供迭代器，无法直接遍历元素。于是我在dfs算法中用deque双端队列模拟栈，在bfs算法中用数组来模拟栈。 2.关于方向处理的问题起初我选择不同方向走用了四个if来判断，然后用一个变量来记录判过哪个方向，使得代码十分冗余，后来，我使用d数组来存储不同的方向，简化了代码。 3.bfs算法中对路径的存储问题最后采用链表结构 四、试验小结这次实验我收获了许多：1.我更加熟悉了stl中deque，stack，queue的操作方法和适用条件，并且能针对实际问题用数组去替代实现。2.我学会不使用指针，用结构体的一个整型变量来记录下一个节点的地址来实现链表的功能。3.我学会了用栈写非递归的dfs算法，并且能与递归的dfs算法相互转换。4.我学会了用队列实现bfs算法，并能用链表记录路径。5.我还明白了，在写程序代码前首先要设计好数据结构，尽可能考虑全数据结构要实现的功能，是否选择现成的stl也值得考虑。 五、数据结构1.dfs算法： Road结构体记录坐标 12345678 struct Road { int r,c; Road(){} Road(int x,int y){ r=x,c=y; }}; 使用stl中deque模拟栈 1deque&lt;Road&gt; st; 2.bfs算法： Road结构体记录坐标 1234struct Road { int r,c; int f;}; 结构体中f记录上一个节点在队列中的索引，方便之后的输出路径，实为链表结构 直接用数组模拟队列 123 const int MAXN=1001;Road q[MAXN];//队列int head=0,tail=0; 六、主要算法1.dfs算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;deque&gt;using namespace std;struct Road { int r,c; Road(){} Road(int x,int y){ r=x,c=y; }};bool maze[5][5];//迷宫bool visited[5][5];//是否被访问过int d[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//方向int m,n;int startx,starty,endx,endy;deque&lt;Road&gt; st;void dfs(int x,int y){ st.push_back(Road(x,y)); while(!st.empty()){ Road front = st.back(); int i; for(i=0; i&lt;4; i++){ Road last; last.r=front.r+d[i][0]; last.c=front.c+d[i][1]; if(last.r&gt;=m||last.c&gt;=n||last.r&lt;0||last.c&lt;0)continue; if(maze[last.r][last.c]==0&amp;&amp;visited[last.r][last.c]==0){ visited[last.r][last.c]=1; st.push_back(last); break; } } if(st.back().r == endx &amp;&amp; st.back().c==endy){ for(deque&lt;Road&gt;::iterator it=st.begin();it!=st.end();it++){ printf(\"(%d, %d)\\n\",it-&gt;r,it-&gt;c); } st.pop_back(); continue; } if(i==4)st.pop_back(); }}int main(){ scanf(\"%d%d%d%d%d%d\",&amp;m,&amp;n,&amp;startx,&amp;starty,&amp;endx,&amp;endy); for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { scanf(\"%d\",&amp;maze[i][j]); } } dfs(startx,starty); return 0;} 2.bfs算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;struct Road { int r,c; int f;};const int MAXN=1001;Road q[MAXN];//队列int head=0,tail=0;bool maze[5][5];//迷宫bool visited[5][5];//是否被访问过int d[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//方向int m,n;int startx,starty,endx,endy;void bfs(){ while (head&lt;tail) { Road front=q[head];//保存队头 if (front.c==endx&amp;&amp;front.r==endy) { //达到终点退出循环 break; } for (int i=0;i&lt;4;i++) { Road last; last.r=front.r+d[i][0]; last.c=front.c+d[i][1]; if (last.r&gt;=0&amp;&amp;last.r&lt;m&amp;&amp;last.c&lt;n&amp;&amp;last.c&gt;=0) { if (!visited[last.r][last.c]&amp;&amp;!maze[last.r][last.c]) { last.f=head;//记录入队前head值方便之后打印路径 q[tail++]=last;//入队 visited[last.r][last.c]=true;//已经访问，做上标记 } } } //出队 head++; }}int main(){ int path[30]; scanf(\"%d%d%d%d%d%d\",&amp;m,&amp;n,&amp;startx,&amp;starty,&amp;endx,&amp;endy); for (int i=0;i&lt;5;i++) { for (int j=0;j&lt;5;j++) { scanf(\"%d\",&amp;maze[i][j]); } } Road a={0,0,-1}; q[tail++]=a; visited[0][0]=1; bfs(); int i=0; while (q[head].f&gt;=0) { path[i++]=q[head].f; head=path[i-1]; } for (int j=i-1;j&gt;=0;j--) { printf(\"(%d, %d)\\n\",q[path[j]].r,q[path[j]].c); } printf(\"(%d, %d)\",endx,endy); return 0;}","path":"2019/10/21/2019-10-19/数据结构试验报告-栈和队列/","date":"10-21","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"算法","slug":"算法","permalink":"https://fnsflm.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://fnsflm.xyz/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://fnsflm.xyz/tags/%E9%98%9F%E5%88%97/"}]},{"title":"爱数社招新试题解答","text":"爱数社招新试题解答Stolz定理的应用预备知识： 1.stolz定理 若数列{} {}满足{}严格单调递增且，且=L，(其中L可以为有限实数，也可以为),则=L 2.stolz定理 若数列{}{}满足{}严格单调递减且，且=L，(其中L可以为有限实数，也可以为),则=L 3.f(n)&gt;0,且极限存在的条件下，有f(n)= 习题及解答(以下所有习题均不需要使用-N语言)1.求极限 2.=A，讨论下列四个式子的极限： (1) (2) (3) (4)解：以上四个式子在&gt;0时（不仅限）极限值均为A（1）恒不为0时，极限值为A把分子的n除到分母，对分母使用stolz（2）在&gt;0时，极限值为A用预备知识3.取对数后的极限使用stolz(3）直接使用stolz(4)用预备知识3.取对数后的极限使用stolz 3.数列{} {}的极限分别为A，B求证： 4.若数列{}满足,求 5.若正数列{}满足,求极限 6.求极限： 解：=== == = = 附：stolze定理的证明 参考文件群文件：1.不等式在求极限中的应用两例2.例谈stolz定理的应用 拓展群文件：tooeplitz定理的推广","path":"2019/10/11/2019-9-20/爱数社招新试题解答/","date":"10-11","excerpt":"","tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://fnsflm.xyz/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"数据结构实验报告-链表","text":"数据结构实验报告-链表一、实验题目与目的 题目：约瑟夫问题 n个人(n&lt;=100)围成一圈,从第一个人开始报数,数到m的人出列,再由下一个人重新从1开始报数,数到m的人再出圈,……依次类推,直到所有的人都出圈,请输出依次出圈人的编号. 目的：用不同的数据结构和算法解决并优化约瑟夫问题二、实验环境 操作系统：Ubuntu 18.04 LTS IDE：CLion OJ：洛谷 题目：https://www.luogu.org/problem/P1996 测试点：5个 三、实验问题原代码 使用结构体+指针实现循环单链表 从表头开始循环遍历，用t计数，m表示每m个人就弹出（删除并打印），直到链表为空为止 耗时：11ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;//定义链表typedef struct LNode *List;struct LNode { int data; List next;};List head=(List)malloc(sizeof(LNode));int size;//向表中插入元素，并返回插入点的指针，此题用来创建初始链表List insert(List position,int data){ List p=head; while(p!=position){ p=p-&gt;next; }List tmp=(List)malloc(sizeof(LNode)); tmp-&gt;data=data; tmp-&gt;next=p-&gt;next; p-&gt;next=tmp; return tmp;}//删除指针位置后的一个节点，并返回删除点后一个节点的指针List del(List position){ List p=position-&gt;next; printf(\"%d \",position-&gt;next-&gt;data); position-&gt;next=position-&gt;next-&gt;next; free(p); size--; return position-&gt;next;}int main(){ int n,m; scanf(\"%d%d\",&amp;n,&amp;m); //初始化循环单链表 head-&gt;next=head; head-&gt;data=1; List before=head; for(int i=2;i&lt;=n;i++){ before=insert(before,i); } size=n; int t=0; List p=head; //当表不空时循环遍历，t计数 while(size){ if(t&lt;m-2)t++,p=p-&gt;next; else{ t=0; p=del(p); } } return 0;} 问题 用指针链表实现该问题，因为终止位置考虑不细致，终止条件错误，末尾指针未指向null等，容易出现段错误 (核心已转储)的错误 创建表，删除元素等操作编写起来繁琐且容易出错，编程效率较低 四、数据结构 原代码：结构体+指针实现循环单链表 12345typedef struct LNode *List;struct LNode { int data; List next;}; 5.1.1：二位数组（或结构体数组）实现循环单链表 12int list[10001][2];int size; 5.1.2：stl链表（双向链表）模拟循环链表 1234#include &lt;list&gt;using namespace std;list&lt;int&gt; ls;list&lt;int&gt;::iterator it; 5.2.2：数组（或结构体数组）实现队列 12345int queue[100001];int front=1;int rear=1;#define pop() queue[front++]#define push(x) queue[rear++]=x 五、解决方案1.1避开指针，使用数组实现链表 使用二维整型数组（如果链表存储的不是整型，则可以使用结构体数组）来实现链表 数组的第二维存接下来元素的序号，数组的第几个而不是真实的物理地址 算法与原来的相同 耗时：10ms 注：可用vector实现动态数组，这里没有内存的限制所以直接用较长数组实现 代码 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;//创建二位数组，记录链表长度sizeint list[10001][2];int size;int main(){ int n,m; scanf(\"%d%d\",&amp;n,&amp;m); //创建链表，第1维存入数据，第2维存入下一个节点位置i+1，并把最后一个指向头结点 for(int i=1;i&lt;=n;i++){ list[i][0]=i; list[i][1]=i+1; } list[n][1]=1; size = n; int p=1,t=1; //当表不空时循环遍历，t计数 while(size){ if(t&lt;m-1)t++,p=list[p][1]; else{ t=1; printf(\"%d \",list[list[p][1]][0]); //删除操作： list[p][1]=list[list[p][1]][1]; p=list[p][1]; size--; } } return 0;} 1.2使用stl实现（优化） 使用stl的list来创建链表 迭代器模拟遍历循环链表 耗时：12ms 代码： 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;list&gt;using namespace std;int main() { //链表总个数n，每m个结点弹出，创建链表ls和迭代器list int n,m； list&lt;int&gt; ls; list&lt;int&gt;::iterator it; scanf(\"%d %d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ ls.push_back(i); } it=ls.begin(); int t=1; //当表不空时循环遍历，t计数，每当t等与m时弹出元素，t清零 while(!ls.empty()){ if(t==m){ printf(\"%d \",*it); t=1; it=ls.erase(it); }else{ it++;t++; } //迭代器遍历到链表末时，重头开始遍历，模拟循环链表 if(it==ls.end())it=ls.begin(); } return 0;} 2.1使用stl实现（优化） 2.2使用队列来实现 开一个足够长的数组模拟队列 使用t计数，当t不为到m时，队头出队并压如队尾，t等与m时直接出队 头front等于尾rear时退出循环结束程序 耗时：10ms 代码 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;//创建足够长的数组作为队列，并定义头尾和基本入队出队操作int queue[100001];int front=1;int rear=1;#define pop() queue[front++]#define push(x) queue[rear++]=xint main() { int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) push(i); int t=0; //同样使用t计数，当t不为到m时，队头出队并压如队尾，t等与m时直接出队 while(rear&gt;front){ if(t&lt;m-1){ t++; push(pop()); } else{ t=0; printf(\"%d \",pop()); } } return 0;} 六、实验小结在这次数据结构实验中，我学会了链表的使用，如创建，插入，删除，遍历等基本操作。然后，针对于约瑟夫问题，我对常出现的错误，以及较低编程效率，提出了自己的解决方案。我调整了数据结构及算法，或者利用了stl工具，对约瑟夫问题进行求解，其中最后一种使用队列作为来处理该问题编程效率较高且运行效率较高。此外，这些方法不仅仅使用与这一个问题，还能够推广到其它的问题，尤其是针对与链表的优化与处理。","path":"2019/09/21/2019-9-21/数据结构实验报告-链表/","date":"09-21","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"算法","slug":"算法","permalink":"https://fnsflm.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://fnsflm.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Linux下vscode C语言 对pow、exp未定义引用问题","text":"Linux下vscode C语言 对pow、exp未定义引用问题 问题描述 原因 解决方法 结果 补充 补充 问题描述头文件使用math库时会出现“未定义引用”问题报错： /tmp/cct7CPFw.o：在函数‘main’中：19012705.c:(.text+0x88)：对‘pow’未定义的引用collect2: error: ld returned 1 exit status 源代码： 1234567891011121314#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define e 2.718281828int main(){ float temperature, dewpoint, humidex; while (scanf(\"T %f D %f\", &amp;temperature, &amp;dewpoint) == 2) { getchar(); humidex = temperature + (0.5555) * (-10 + 6.11 * pow(e, (5417.7530 * ((1 / 273.16) - (1 / (dewpoint + 273.16)))))); printf(\"T %.1f D %.1f H %.1f\\n\", temperature, dewpoint, humidex); } return 0;} 在linux终端下也会出现一样问题 原因linux中gcc没有默认链接math库 解决方法vscode工作区文件夹下有一个.vscode文件夹（没有就创建），在该文件下打开settings.json（没有就创建）左侧的4复制到右侧在“C”如图加上-lm，保存即可 结果)` 补充linux上c语言的函数库在/usr/lib/目录下，以lib*开头.so为后缀,*为库的名称，比如math库是libm.so,stdio库是libc.so。gcc命令末尾-l库名称就能链接函数库 ………………………………………………………………………………………………………….. 补充以上内容其实是对code runner插件问题的解决，在调试中仍然会出现问题，这时需要对./.vscode/tasks.json文件进行修改","path":"2018/02/18/2019-2-18/Linux下vscode-C语言-对pow、exp未定义引用问题/","date":"02-18","excerpt":"","tags":[{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"vscode","slug":"vscode","permalink":"https://fnsflm.xyz/tags/vscode/"},{"name":"linux","slug":"linux","permalink":"https://fnsflm.xyz/tags/linux/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"1999/04/14/1999-4-14/hello-world/","date":"04-14","excerpt":"","tags":[]}],"categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://fnsflm.xyz/tags/css/"},{"name":"hexo","slug":"hexo","permalink":"https://fnsflm.xyz/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://fnsflm.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"js","slug":"js","permalink":"https://fnsflm.xyz/tags/js/"},{"name":"html","slug":"html","permalink":"https://fnsflm.xyz/tags/html/"},{"name":"gulp","slug":"gulp","permalink":"https://fnsflm.xyz/tags/gulp/"},{"name":"telegram","slug":"telegram","permalink":"https://fnsflm.xyz/tags/telegram/"},{"name":"ACGN","slug":"ACGN","permalink":"https://fnsflm.xyz/tags/ACGN/"},{"name":"安装配置","slug":"安装配置","permalink":"https://fnsflm.xyz/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"bug","slug":"bug","permalink":"https://fnsflm.xyz/tags/bug/"},{"name":"win7","slug":"win7","permalink":"https://fnsflm.xyz/tags/win7/"},{"name":"前端","slug":"前端","permalink":"https://fnsflm.xyz/tags/%E5%89%8D%E7%AB%AF/"},{"name":"linux","slug":"linux","permalink":"https://fnsflm.xyz/tags/linux/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://fnsflm.xyz/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"服务器","slug":"服务器","permalink":"https://fnsflm.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"网络","slug":"网络","permalink":"https://fnsflm.xyz/tags/%E7%BD%91%E7%BB%9C/"},{"name":"android","slug":"android","permalink":"https://fnsflm.xyz/tags/android/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://fnsflm.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"python","slug":"python","permalink":"https://fnsflm.xyz/tags/python/"},{"name":"pyecharts","slug":"pyecharts","permalink":"https://fnsflm.xyz/tags/pyecharts/"},{"name":"绘图","slug":"绘图","permalink":"https://fnsflm.xyz/tags/%E7%BB%98%E5%9B%BE/"},{"name":"数据可视化","slug":"数据可视化","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"关系图","slug":"关系图","permalink":"https://fnsflm.xyz/tags/%E5%85%B3%E7%B3%BB%E5%9B%BE/"},{"name":"java","slug":"java","permalink":"https://fnsflm.xyz/tags/java/"},{"name":"大数据","slug":"大数据","permalink":"https://fnsflm.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"kafka","permalink":"https://fnsflm.xyz/tags/kafka/"},{"name":"hbase","slug":"hbase","permalink":"https://fnsflm.xyz/tags/hbase/"},{"name":"hadoop","slug":"hadoop","permalink":"https://fnsflm.xyz/tags/hadoop/"},{"name":"mapreduce","slug":"mapreduce","permalink":"https://fnsflm.xyz/tags/mapreduce/"},{"name":"爬虫","slug":"爬虫","permalink":"https://fnsflm.xyz/tags/%E7%88%AC%E8%99%AB/"},{"name":"javafx","slug":"javafx","permalink":"https://fnsflm.xyz/tags/javafx/"},{"name":"数据库","slug":"数据库","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"https://fnsflm.xyz/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://fnsflm.xyz/tags/sql/"},{"name":"fcitx","slug":"fcitx","permalink":"https://fnsflm.xyz/tags/fcitx/"},{"name":"kdenlive","slug":"kdenlive","permalink":"https://fnsflm.xyz/tags/kdenlive/"},{"name":"pixiv","slug":"pixiv","permalink":"https://fnsflm.xyz/tags/pixiv/"},{"name":"nginx","slug":"nginx","permalink":"https://fnsflm.xyz/tags/nginx/"},{"name":"x.org","slug":"x-org","permalink":"https://fnsflm.xyz/tags/x-org/"},{"name":"wine","slug":"wine","permalink":"https://fnsflm.xyz/tags/wine/"},{"name":"github","slug":"github","permalink":"https://fnsflm.xyz/tags/github/"},{"name":"github action","slug":"github-action","permalink":"https://fnsflm.xyz/tags/github-action/"},{"name":"c/c++","slug":"c-c","permalink":"https://fnsflm.xyz/tags/c-c/"},{"name":"vscode","slug":"vscode","permalink":"https://fnsflm.xyz/tags/vscode/"},{"name":"tenserflow","slug":"tenserflow","permalink":"https://fnsflm.xyz/tags/tenserflow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://fnsflm.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"cuda","slug":"cuda","permalink":"https://fnsflm.xyz/tags/cuda/"},{"name":"高等数学","slug":"高等数学","permalink":"https://fnsflm.xyz/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"navicat","slug":"navicat","permalink":"https://fnsflm.xyz/tags/navicat/"},{"name":"数据结构","slug":"数据结构","permalink":"https://fnsflm.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://fnsflm.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://fnsflm.xyz/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"排序","slug":"排序","permalink":"https://fnsflm.xyz/tags/%E6%8E%92%E5%BA%8F/"},{"name":"树","slug":"树","permalink":"https://fnsflm.xyz/tags/%E6%A0%91/"},{"name":"算法 - 字符串","slug":"算法-字符串","permalink":"https://fnsflm.xyz/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"栈","slug":"栈","permalink":"https://fnsflm.xyz/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://fnsflm.xyz/tags/%E9%98%9F%E5%88%97/"},{"name":"链表","slug":"链表","permalink":"https://fnsflm.xyz/tags/%E9%93%BE%E8%A1%A8/"}]}